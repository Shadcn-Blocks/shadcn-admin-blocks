{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Form",
  "type": "registry:block",
  "title": "Form",
  "description": "Enhanced form field components that wrap the entire shadcn/ui FormField pattern into single, easy-to-use components. Dramatically reduces boilerplate while maintaining full React Hook Form compatibility.",
  "dependencies": [
    "react-hook-form",
    "@hookform/resolvers",
    "zod",
    "date-fns",
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "input",
    "label",
    "select",
    "checkbox",
    "textarea",
    "form",
    "calendar",
    "popover"
  ],
  "files": [
    {
      "path": "registry/components/form/FormFieldWrapper.tsx",
      "content": "import * as React from 'react'\nimport {\n  FieldPath,\n  FieldValues,\n  useFormContext,\n  ControllerRenderProps,\n} from 'react-hook-form'\nimport {\n  FormField,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n} from '@/components/ui/form'\nimport {\n  BaseFormFieldProps,\n  FieldRenderFunction,\n  LayoutRenderFunction,\n} from '@/lib/form/types'\n\ninterface FormFieldWrapperProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> extends BaseFormFieldProps<TFieldValues, TName> {\n  children: FieldRenderFunction<TFieldValues, TName>\n  renderLayout?: LayoutRenderFunction<TFieldValues, TName>\n}\n\nexport const FormFieldWrapper = React.memo(\n  <\n    TFieldValues extends FieldValues = FieldValues,\n    TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  >({\n    name,\n    control,\n    defaultValue,\n    rules,\n    shouldUnregister,\n    disabled,\n    label,\n    description,\n    className,\n    children,\n    renderLayout,\n  }: FormFieldWrapperProps<TFieldValues, TName>) => {\n    const form = useFormContext<TFieldValues>()\n\n    // Memoize field control to prevent unnecessary context reads\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const fieldControl = React.useMemo(() => control || form.control, [control])\n\n    // Memoize the render function to prevent child re-renders\n    const renderField = React.useCallback(\n      ({ field }: { field: ControllerRenderProps<TFieldValues, TName> }) => {\n        const childElement = children(field)\n\n        if (renderLayout) {\n          return (\n            <FormItem className={className}>\n              {renderLayout({\n                field,\n                label,\n                description,\n                children: childElement,\n              })}\n              <FormMessage />\n            </FormItem>\n          )\n        }\n\n        return (\n          <FormItem className={className}>\n            {label && <FormLabel>{label}</FormLabel>}\n            <FormControl>{childElement}</FormControl>\n            {description && <FormDescription>{description}</FormDescription>}\n            <FormMessage />\n          </FormItem>\n        )\n      },\n      [children, renderLayout, className, label, description],\n    )\n\n    return (\n      <FormField\n        control={fieldControl}\n        name={name}\n        defaultValue={defaultValue}\n        rules={rules}\n        shouldUnregister={shouldUnregister}\n        disabled={disabled}\n        render={renderField}\n      />\n    )\n  },\n) as <TFieldValues extends FieldValues, TName extends FieldPath<TFieldValues>>(\n  props: FormFieldWrapperProps<TFieldValues, TName>,\n) => React.ReactElement\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/Form.tsx",
      "content": "import * as React from 'react'\nimport { FieldValues, UseFormReturn, useForm, UseFormProps } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { z } from 'zod'\nimport { Form as ShadcnForm } from '@/components/ui/form'\n\n// Context for sharing form submission state with submit buttons\ninterface FormSubmissionContextValue {\n  isSubmitting: boolean\n}\n\nconst FormSubmissionContext = React.createContext<FormSubmissionContextValue | null>(null)\n\nexport const useFormSubmissionState = () => {\n  const context = React.useContext(FormSubmissionContext)\n  if (!context) {\n    throw new Error('useFormSubmissionState must be used within a Form')\n  }\n  return context\n}\n\n// Props when providing an existing form instance\ninterface FormPropsWithForm<TFieldValues extends FieldValues = FieldValues> {\n  form: UseFormReturn<TFieldValues>\n  onSubmit: (data: TFieldValues) => void | Promise<void>\n  children: React.ReactNode\n  className?: string\n  /**\n   * Whether to prevent default form submission behavior.\n   * Set to false if you want to handle form submission manually.\n   * @default true\n   */\n  preventDefault?: boolean\n}\n\n// Props when providing a Zod schema (Form creates the form internally)\ninterface FormPropsWithSchema<TSchema extends z.ZodType<any, any, any>> {\n  schema: TSchema\n  defaultValues?: Partial<z.infer<TSchema>>\n  onSubmit: (data: z.infer<TSchema>) => void | Promise<void>\n  children: React.ReactNode\n  className?: string\n  /**\n   * Whether to prevent default form submission behavior.\n   * Set to false if you want to handle form submission manually.\n   * @default true\n   */\n  preventDefault?: boolean\n  /**\n   * Additional useForm options (mode, reValidateMode, etc.)\n   */\n  formOptions?: Omit<UseFormProps<z.infer<TSchema>>, 'resolver' | 'defaultValues'>\n}\n\n// Form component with schema support\nfunction FormWithSchema<TSchema extends z.ZodType<any, any, any>>({\n  schema,\n  defaultValues,\n  onSubmit,\n  children,\n  className = \"space-y-6\",\n  preventDefault = true,\n  formOptions = {},\n}: FormPropsWithSchema<TSchema>) {\n  const [isSubmitting, setIsSubmitting] = React.useState(false)\n\n  // Create the form instance internally\n  const form = useForm<z.infer<TSchema>>({\n    resolver: zodResolver(schema) as any,\n    defaultValues: defaultValues as z.infer<TSchema>,\n    ...formOptions,\n  })\n\n  const handleSubmit = React.useCallback(async (data: z.infer<TSchema>) => {\n    setIsSubmitting(true)\n    try {\n      await onSubmit(data)\n    } finally {\n      setIsSubmitting(false)\n    }\n  }, [onSubmit])\n\n  const submitHandler = form.handleSubmit(handleSubmit)\n\n  return (\n    <FormSubmissionContext.Provider value={{ isSubmitting }}>\n      <ShadcnForm {...form}>\n        <form \n          onSubmit={preventDefault ? submitHandler : undefined}\n          className={className}\n          noValidate\n        >\n          {children}\n        </form>\n      </ShadcnForm>\n    </FormSubmissionContext.Provider>\n  )\n}\n\n// Form component with existing form instance\nfunction FormWithForm<TFieldValues extends FieldValues = FieldValues>({\n  form,\n  onSubmit,\n  children,\n  className = \"space-y-6\",\n  preventDefault = true,\n}: FormPropsWithForm<TFieldValues>) {\n  const [isSubmitting, setIsSubmitting] = React.useState(false)\n\n  const handleSubmit = React.useCallback(async (data: TFieldValues) => {\n    setIsSubmitting(true)\n    try {\n      await onSubmit(data)\n    } finally {\n      setIsSubmitting(false)\n    }\n  }, [onSubmit])\n\n  const submitHandler = form.handleSubmit(handleSubmit)\n\n  return (\n    <FormSubmissionContext.Provider value={{ isSubmitting }}>\n      <ShadcnForm {...form}>\n        <form \n          onSubmit={preventDefault ? submitHandler : undefined}\n          className={className}\n          noValidate\n        >\n          {children}\n        </form>\n      </ShadcnForm>\n    </FormSubmissionContext.Provider>\n  )\n}\n\n// Union type for all possible Form props\nexport type FormProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TSchema extends z.ZodType<any, any, any> = z.ZodType<any, any, any>\n> = FormPropsWithForm<TFieldValues> | FormPropsWithSchema<TSchema>\n\n// Main Form component with proper typing using function overloads\ninterface FormComponentInterface {\n  <TSchema extends z.ZodType<any, any, any>>(\n    props: FormPropsWithSchema<TSchema>\n  ): React.ReactElement\n  <TFieldValues extends FieldValues = FieldValues>(\n    props: FormPropsWithForm<TFieldValues>\n  ): React.ReactElement\n  displayName?: string\n}\n\nconst FormComponent: FormComponentInterface = <\n  TFieldValues extends FieldValues = FieldValues,\n  TSchema extends z.ZodType<any, any, any> = z.ZodType<any, any, any>\n>(props: FormProps<TFieldValues, TSchema>): React.ReactElement => {\n  // Check if props has 'schema' property to determine which variant to use\n  if ('schema' in props) {\n    return <FormWithSchema {...props} />\n  } else {\n    return <FormWithForm {...props} />\n  }\n}\n\nexport const Form = FormComponent\n\nForm.displayName = 'Form'",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/FormSubmitButton.tsx",
      "content": "import * as React from 'react'\nimport { Button } from '@/components/ui/button'\nimport { Loader2 } from 'lucide-react'\nimport { useFormSubmissionState } from '@/components/form/Form'\n\ninterface FormSubmitButtonProps extends Omit<React.ComponentProps<typeof Button>, 'type'> {\n  /**\n   * Custom loading text to show when submitting\n   * @default \"Submitting...\"\n   */\n  loadingText?: string\n  /**\n   * Custom loading icon\n   * @default Loader2 (spinning)\n   */\n  loadingIcon?: React.ReactNode\n  /**\n   * Whether to show loading icon\n   * @default true\n   */\n  showLoadingIcon?: boolean\n  /**\n   * Button content\n   */\n  children: React.ReactNode\n}\n\nexport const FormSubmitButton = React.forwardRef<HTMLButtonElement, FormSubmitButtonProps>(\n  ({ children, loadingText = \"Submitting...\", loadingIcon, showLoadingIcon = true, disabled, ...props }, ref) => {\n    const { isSubmitting } = useFormSubmissionState()\n\n    const defaultLoadingIcon = showLoadingIcon ? <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" /> : null\n    const finalLoadingIcon = loadingIcon ?? defaultLoadingIcon\n\n    return (\n      <Button\n        ref={ref}\n        type=\"submit\"\n        disabled={disabled || isSubmitting}\n        {...props}\n      >\n        {isSubmitting ? (\n          <>\n            {finalLoadingIcon}\n            {loadingText}\n          </>\n        ) : (\n          children\n        )}\n      </Button>\n    )\n  }\n)\n\nFormSubmitButton.displayName = 'FormSubmitButton'",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/FormFieldInput.tsx",
      "content": "import * as React from 'react'\nimport { FieldPath, FieldValues, ControllerRenderProps } from 'react-hook-form'\nimport { Input } from '@/components/ui/input'\nimport { FormFieldWrapper } from '@/components/form/FormFieldWrapper'\nimport { TypedFormFieldProps } from '@/lib/form/types'\n\ninterface FormFieldInputProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> extends TypedFormFieldProps<\n    TFieldValues,\n    TName,\n    React.ComponentProps<typeof Input>\n  > {}\n\nexport const FormFieldInput = React.memo(\n  <\n    TFieldValues extends FieldValues = FieldValues,\n    TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  >({\n    name,\n    control,\n    defaultValue,\n    rules,\n    shouldUnregister,\n    disabled,\n    label,\n    description,\n    className,\n    ...inputProps\n  }: FormFieldInputProps<TFieldValues, TName>) => {\n    // Memoize the input render function\n    const renderInput = React.useCallback(\n      (field: ControllerRenderProps<TFieldValues, TName>) => (\n        <Input {...field} {...inputProps} />\n      ),\n      [inputProps],\n    )\n\n    return (\n      <FormFieldWrapper\n        name={name}\n        control={control}\n        defaultValue={defaultValue}\n        rules={rules}\n        shouldUnregister={shouldUnregister}\n        disabled={disabled}\n        label={label}\n        description={description}\n        className={className}>\n        {renderInput}\n      </FormFieldWrapper>\n    )\n  },\n) as <TFieldValues extends FieldValues, TName extends FieldPath<TFieldValues>>(\n  props: FormFieldInputProps<TFieldValues, TName>,\n) => React.ReactElement\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/FormFieldTextarea.tsx",
      "content": "import * as React from 'react'\nimport { FieldPath, FieldValues } from 'react-hook-form'\nimport { Textarea } from '@/components/ui/textarea'\nimport { FormFieldWrapper } from '@/components/form/FormFieldWrapper'\nimport { TypedFormFieldProps } from '@/lib/form/types'\n\ninterface FormFieldTextareaProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> extends TypedFormFieldProps<TFieldValues, TName, React.ComponentProps<typeof Textarea>> {}\n\nexport const FormFieldTextarea = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>({\n  name,\n  control,\n  defaultValue,\n  rules,\n  shouldUnregister,\n  disabled,\n  label,\n  description,\n  className,\n  ...textareaProps\n}: FormFieldTextareaProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldWrapper\n      name={name}\n      control={control}\n      defaultValue={defaultValue}\n      rules={rules}\n      shouldUnregister={shouldUnregister}\n      disabled={disabled}\n      label={label}\n      description={description}\n      className={className}\n    >\n      {(field) => <Textarea {...field} {...textareaProps} />}\n    </FormFieldWrapper>\n  )\n}\n\nFormFieldTextarea.displayName = 'FormFieldTextarea'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/FormFieldSelect.tsx",
      "content": "import * as React from 'react'\nimport { FieldPath, FieldValues } from 'react-hook-form'\nimport { Select, SelectContent, SelectTrigger, SelectValue } from '@/components/ui/select'\nimport { FormFieldWrapper } from '@/components/form/FormFieldWrapper'\nimport { BaseFormFieldProps, FieldValueType } from '@/lib/form/types'\n\ninterface FormFieldSelectProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> extends BaseFormFieldProps<TFieldValues, TName> {\n  placeholder?: string\n  children: React.ReactNode\n}\n\n// Type constraint to ensure select fields accept string values\ntype SelectFieldPath<TFieldValues extends FieldValues> = {\n  [K in FieldPath<TFieldValues>]: FieldValueType<TFieldValues, K> extends string | undefined\n    ? K\n    : never\n}[FieldPath<TFieldValues>]\n\nexport const FormFieldSelect = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends SelectFieldPath<TFieldValues> = SelectFieldPath<TFieldValues>,\n>({\n  name,\n  control,\n  defaultValue,\n  rules,\n  shouldUnregister,\n  disabled,\n  label,\n  description,\n  placeholder,\n  children,\n  className,\n}: FormFieldSelectProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldWrapper\n      name={name}\n      control={control}\n      defaultValue={defaultValue}\n      rules={rules}\n      shouldUnregister={shouldUnregister}\n      disabled={disabled}\n      label={label}\n      description={description}\n      className={className}\n    >\n      {(field) => (\n        <Select onValueChange={field.onChange} value={field.value} disabled={disabled}>\n          <SelectTrigger>\n            <SelectValue placeholder={placeholder} />\n          </SelectTrigger>\n          <SelectContent>{children}</SelectContent>\n        </Select>\n      )}\n    </FormFieldWrapper>\n  )\n}\n\nFormFieldSelect.displayName = 'FormFieldSelect'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/FormFieldCheckbox.tsx",
      "content": "import * as React from 'react'\nimport { FieldPath, FieldValues } from 'react-hook-form'\nimport { FormControl, FormDescription, FormLabel } from '@/components/ui/form'\nimport { Checkbox } from '@/components/ui/checkbox'\nimport { FormFieldWrapper } from '@/components/form/FormFieldWrapper'\nimport { BaseFormFieldProps, FieldValueType } from '@/lib/form/types'\n\ninterface FormFieldCheckboxProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> extends BaseFormFieldProps<TFieldValues, TName> {\n  children?: React.ReactNode\n}\n\n// Type constraint to ensure checkbox fields are boolean-compatible\ntype CheckboxFieldPath<TFieldValues extends FieldValues> = {\n  [K in FieldPath<TFieldValues>]: FieldValueType<TFieldValues, K> extends boolean | undefined\n    ? K\n    : never\n}[FieldPath<TFieldValues>]\n\nexport const FormFieldCheckbox = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends CheckboxFieldPath<TFieldValues> = CheckboxFieldPath<TFieldValues>,\n>({\n  name,\n  control,\n  defaultValue,\n  rules,\n  shouldUnregister,\n  disabled,\n  label,\n  description,\n  children,\n  className,\n}: FormFieldCheckboxProps<TFieldValues, TName>) => {\n  // If children or label are provided, use the integrated checkbox+label style\n  if (children || label) {\n    return (\n      <FormFieldWrapper\n        name={name}\n        control={control}\n        defaultValue={defaultValue}\n        rules={rules}\n        shouldUnregister={shouldUnregister}\n        disabled={disabled}\n        className={className}\n        renderLayout={({ children: checkbox }) => {\n          const checkboxId = `${name}-checkbox`\n          return (\n            <div className=\"flex flex-row items-start space-x-3 space-y-0\">\n              <FormControl>{React.cloneElement(checkbox as React.ReactElement<any>, { id: checkboxId })}</FormControl>\n              <div className=\"space-y-1 leading-none\">\n                {(children || label) && (\n                  <FormLabel htmlFor={checkboxId} className=\"cursor-pointer font-normal leading-5\">\n                    {children || label}\n                  </FormLabel>\n                )}\n                {description && <FormDescription>{description}</FormDescription>}\n              </div>\n            </div>\n          )\n        }}\n      >\n        {(field) => (\n          <Checkbox checked={field.value} onCheckedChange={field.onChange} disabled={disabled} />\n        )}\n      </FormFieldWrapper>\n    )\n  }\n\n  // Simple checkbox without integrated label\n  return (\n    <FormFieldWrapper\n      name={name}\n      control={control}\n      defaultValue={defaultValue}\n      rules={rules}\n      shouldUnregister={shouldUnregister}\n      disabled={disabled}\n      label={label}\n      description={description}\n      className={className}\n    >\n      {(field) => (\n        <Checkbox checked={field.value} onCheckedChange={field.onChange} disabled={disabled} />\n      )}\n    </FormFieldWrapper>\n  )\n}\n\nFormFieldCheckbox.displayName = 'FormFieldCheckbox'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/FormFieldDatePicker.tsx",
      "content": "import { FieldPath, FieldValues } from 'react-hook-form'\nimport { Button } from '@/components/ui/button'\nimport { Calendar } from '@/components/ui/calendar'\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'\nimport { CalendarIcon } from 'lucide-react'\nimport { dateUtils } from '@/lib/form/date-utils'\nimport { cn } from '@/lib/utils'\nimport { FormFieldWrapper } from '@/components/form/FormFieldWrapper'\nimport { BaseFormFieldProps, FieldValueType } from '@/lib/form/types'\n\ninterface FormFieldDatePickerProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> extends BaseFormFieldProps<TFieldValues, TName> {\n  placeholder?: string\n  dateFormat?: string\n  min?: Date\n  max?: Date\n}\n\n// Type constraint to ensure date picker fields accept Date values\ntype DateFieldPath<TFieldValues extends FieldValues> = {\n  [K in FieldPath<TFieldValues>]: FieldValueType<TFieldValues, K> extends Date | undefined\n    ? K\n    : never\n}[FieldPath<TFieldValues>]\n\nexport const FormFieldDatePicker = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends DateFieldPath<TFieldValues> = DateFieldPath<TFieldValues>,\n>({\n  name,\n  control,\n  defaultValue,\n  rules,\n  shouldUnregister,\n  disabled,\n  label,\n  description,\n  placeholder = 'Pick a date',\n  dateFormat = 'PPP',\n  min,\n  max,\n  className,\n}: FormFieldDatePickerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldWrapper\n      name={name}\n      control={control}\n      defaultValue={defaultValue}\n      rules={rules}\n      shouldUnregister={shouldUnregister}\n      disabled={disabled}\n      label={label}\n      description={description}\n      className={className}\n    >\n      {(field) => (\n        <Popover>\n          <PopoverTrigger asChild>\n            <Button\n              variant=\"outline\"\n              className={cn(\n                'w-full justify-start text-left font-normal',\n                !field.value && 'text-muted-foreground'\n              )}\n              disabled={disabled}\n            >\n              <CalendarIcon className=\"mr-2 h-4 w-4\" />\n              {field.value ? dateUtils.formatForDisplay(field.value, dateFormat) : placeholder}\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-auto p-0\" align=\"start\">\n            <Calendar\n              mode=\"single\"\n              selected={field.value}\n              onSelect={field.onChange}\n              disabled={(date) => {\n                if (disabled) return true\n                if (min && date < min) return true\n                if (max && date > max) return true\n                return false\n              }}\n              autoFocus\n            />\n          </PopoverContent>\n        </Popover>\n      )}\n    </FormFieldWrapper>\n  )\n}\n\nFormFieldDatePicker.displayName = 'FormFieldDatePicker'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/FormFieldNumber.tsx",
      "content": "import * as React from 'react'\nimport { FieldPath, FieldValues } from 'react-hook-form'\nimport { Input } from '@/components/ui/input'\nimport { FormFieldWrapper } from '@/components/form/FormFieldWrapper'\nimport { TypedFormFieldProps } from '@/lib/form/types'\n\ninterface FormFieldNumberProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> extends TypedFormFieldProps<TFieldValues, TName, React.ComponentProps<typeof Input>> {}\n\nexport const FormFieldNumber = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>({\n  name,\n  control,\n  defaultValue,\n  rules,\n  shouldUnregister,\n  disabled,\n  label,\n  description,\n  className,\n  ...inputProps\n}: FormFieldNumberProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldWrapper\n      name={name}\n      control={control}\n      defaultValue={defaultValue}\n      rules={rules}\n      shouldUnregister={shouldUnregister}\n      disabled={disabled}\n      label={label}\n      description={description}\n      className={className}\n    >\n      {(field) => <Input {...field} {...inputProps} type=\"number\" />}\n    </FormFieldWrapper>\n  )\n}\n\nFormFieldNumber.displayName = 'FormFieldNumber'",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/FormDatePicker.tsx",
      "content": "import * as React from 'react'\nimport { format, isValid } from 'date-fns'\nimport { CalendarIcon } from 'lucide-react'\nimport { cn } from '@/lib/utils'\nimport { Button } from '@/components/ui/button'\nimport { Calendar } from '@/components/ui/calendar'\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'\n\n// Simple DatePicker component\nexport interface FormDatePickerProps {\n  value?: Date\n  onValueChange?: (date: Date | undefined) => void\n  placeholder?: string\n  disabled?: boolean\n  className?: string\n  min?: Date\n  max?: Date\n}\n\nexport const FormDatePicker = React.forwardRef<HTMLButtonElement, FormDatePickerProps>(\n  (\n    { value, onValueChange, placeholder = 'Pick a date', disabled, className, min, max, ...props },\n    ref\n  ) => {\n    const disabledDates = React.useCallback(\n      (date: Date) => {\n        if (min && date < min) return true\n        if (max && date > max) return true\n        return false\n      },\n      [min, max]\n    )\n\n    return (\n      <Popover>\n        <PopoverTrigger asChild>\n          <Button\n            ref={ref}\n            variant=\"outline\"\n            className={cn(\n              'w-full justify-start text-left font-normal',\n              !value && 'text-muted-foreground',\n              className\n            )}\n            disabled={disabled}\n            {...props}\n          >\n            {value && isValid(value) ? format(value, 'PPP') : <span>{placeholder}</span>}\n            <CalendarIcon className=\"ml-auto h-4 w-4 opacity-50\" />\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-auto p-0\" align=\"start\">\n          <Calendar\n            mode=\"single\"\n            selected={value}\n            onSelect={onValueChange}\n            disabled={disabledDates}\n            autoFocus\n          />\n        </PopoverContent>\n      </Popover>\n    )\n  }\n)\n\nFormDatePicker.displayName = 'FormDatePicker'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/DateRangePicker.tsx",
      "content": "import * as React from 'react'\nimport { CalendarIcon } from 'lucide-react'\nimport { format } from 'date-fns'\nimport { DateRange } from 'react-day-picker'\nimport { Button } from '@/components/ui/button'\nimport { Calendar } from '@/components/ui/calendar'\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'\nimport { cn } from '@/lib/utils'\n\nexport interface DateRangePickerProps {\n  value?: DateRange\n  onChange?: (value: DateRange | undefined) => void\n  placeholder?: string\n  className?: string\n  disabled?: boolean\n  minDate?: Date\n  maxDate?: Date\n  numberOfMonths?: number\n  disabledDates?: (date: Date) => boolean\n}\n\nfunction useMediaQuery(query: string) {\n  const [matches, setMatches] = React.useState(false)\n\n  React.useEffect(() => {\n    const media = window.matchMedia(query)\n    setMatches(media.matches)\n    \n    const listener = (e: MediaQueryListEvent) => setMatches(e.matches)\n    media.addEventListener('change', listener)\n    return () => media.removeEventListener('change', listener)\n  }, [query])\n\n  return matches\n}\n\nexport const DateRangePicker = React.forwardRef<\n  HTMLButtonElement,\n  DateRangePickerProps\n>(({\n  value,\n  onChange,\n  placeholder = 'Pick a date range',\n  className,\n  disabled,\n  minDate,\n  maxDate,\n  numberOfMonths = 2,\n  disabledDates\n}, ref) => {\n  const [open, setOpen] = React.useState(false)\n  const [localRange, setLocalRange] = React.useState<DateRange | undefined>(value)\n  const [isSelectingNewRange, setIsSelectingNewRange] = React.useState(false)\n  const isDesktop = useMediaQuery('(min-width: 768px)')\n\n  React.useEffect(() => {\n    setLocalRange(value)\n  }, [value])\n\n  React.useEffect(() => {\n    if (!open) {\n      setIsSelectingNewRange(false)\n    }\n  }, [open])\n\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (!open) return\n      \n      if (e.key === 'Escape') {\n        e.preventDefault()\n        setOpen(false)\n        setLocalRange(value)\n      }\n    }\n\n    document.addEventListener('keydown', handleKeyDown)\n    return () => document.removeEventListener('keydown', handleKeyDown)\n  }, [open, value])\n\n  const handleSelect = (range: DateRange | undefined) => {\n    if (!range?.from) {\n      setLocalRange(undefined)\n      onChange?.(undefined)\n      setIsSelectingNewRange(false)\n      return\n    }\n    \n    if (range.from && !range.to) {\n      setLocalRange(range)\n      setIsSelectingNewRange(true)\n      return\n    }\n    \n    if (range.from && range.to) {\n      if (isSelectingNewRange) {\n        setLocalRange(range)\n        onChange?.(range)\n        setOpen(false)\n        setIsSelectingNewRange(false)\n      } else {\n        setLocalRange({ from: range.from, to: undefined })\n        setIsSelectingNewRange(true)\n      }\n    }\n  }\n\n  const isDateDisabled = (date: Date) => {\n    if (disabledDates) {\n      return disabledDates(date)\n    }\n    \n    if (minDate && date < minDate) return true\n    if (maxDate && date > maxDate) return true\n    \n    return false\n  }\n\n  const getAriaLabel = () => {\n    if (localRange?.from && localRange?.to) {\n      return `Date range: ${format(localRange.from, 'MMMM d, yyyy')} to ${format(localRange.to, 'MMMM d, yyyy')}`\n    }\n    if (localRange?.from) {\n      return `Date range starting ${format(localRange.from, 'MMMM d, yyyy')}`\n    }\n    return 'Select date range'\n  }\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          ref={ref}\n          variant=\"outline\"\n          disabled={disabled}\n          className={cn(\n            'justify-start text-left font-normal',\n            !localRange && 'text-muted-foreground',\n            className\n          )}\n          aria-label={getAriaLabel()}\n          aria-expanded={open}\n          aria-haspopup=\"dialog\"\n        >\n          <CalendarIcon className=\"mr-2 h-4 w-4\" />\n          {localRange?.from ? (\n            localRange.to ? (\n              <>\n                {format(localRange.from, 'MMM d, yyyy')} - {format(localRange.to, 'MMM d, yyyy')}\n              </>\n            ) : (\n              format(localRange.from, 'MMM d, yyyy')\n            )\n          ) : (\n            placeholder\n          )}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-auto p-0\" align=\"start\">\n        <Calendar\n          mode=\"range\"\n          defaultMonth={localRange?.from || minDate}\n          selected={localRange}\n          onSelect={handleSelect}\n          numberOfMonths={isDesktop ? numberOfMonths : 1}\n          disabled={isDateDisabled}\n        />\n      </PopoverContent>\n    </Popover>\n  )\n})\n\nDateRangePicker.displayName = 'DateRangePicker'",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/index.ts",
      "content": "export type {\n  BaseFormFieldProps,\n  FieldRenderFunction,\n  LayoutRenderFunction,\n  FieldValueType,\n  TypedFormFieldProps,\n  InputPropsExclude,\n} from '../../lib/form/types'\n\n// Form wrapper to eliminate boilerplate\nexport { Form, useFormSubmissionState } from './Form'\n\n// Smart submit button with automatic loading state\nexport { FormSubmitButton } from './FormSubmitButton'\n\n// FormField wrapper for custom implementations\nexport { FormFieldWrapper } from './FormFieldWrapper'\n\n// Complete FormField components that wrap the entire FormField structure\nexport { FormFieldInput } from './FormFieldInput'\nexport { FormFieldTextarea } from './FormFieldTextarea'\nexport { FormFieldSelect } from './FormFieldSelect'\nexport { FormFieldCheckbox } from './FormFieldCheckbox'\nexport { FormFieldDatePicker } from './FormFieldDatePicker'\nexport { FormFieldNumber } from './FormFieldNumber'\n\n// Standalone date picker component (has substantial logic worth keeping)\nexport { FormDatePicker } from './FormDatePicker'\n\n// Re-export Select components for FormFieldSelect usage\nexport { SelectItem, SelectSeparator, SelectGroup, SelectLabel } from '@/components/ui/select'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/lib/form/date-utils.ts",
      "content": "import dayjs from 'dayjs'\nimport relativeTime from 'dayjs/plugin/relativeTime'\nimport { z } from 'zod'\n\n// Extend dayjs with plugins\ndayjs.extend(relativeTime)\n\n// Date formatting utilities\nexport const dateFormats = {\n  // Common display formats\n  display: 'MMM D, YYYY',\n  displayWithTime: 'MMM D, YYYY h:mm A',\n  short: 'MM/DD/YYYY',\n  iso: 'YYYY-MM-DD',\n  time: 'HH:mm',\n\n  // API formats\n  api: 'YYYY-MM-DD',\n  apiWithTime: 'YYYY-MM-DDTHH:mm:ss',\n\n  // date-fns compatibility formats\n  PPP: 'MMM D, YYYY', // Long localized date format\n} as const\n\n// Date conversion utilities\nexport const dateUtils = {\n  /**\n   * Format a date for display\n   * Supports both dayjs and date-fns format patterns for compatibility\n   */\n  formatForDisplay: (date: string | Date | dayjs.Dayjs, format: string = dateFormats.display) => {\n    // Map common date-fns patterns to dayjs equivalents\n    const formatMap: Record<string, string> = {\n      PPP: dateFormats.PPP,\n      PP: 'MMM D, YYYY',\n      P: 'MM/DD/YYYY',\n    }\n\n    const dayJsFormat = formatMap[format] || format\n    return dayjs(date).format(dayJsFormat)\n  },\n\n  /**\n   * Format a date for HTML input (YYYY-MM-DD)\n   */\n  formatForInput: (date: string | Date | dayjs.Dayjs) => {\n    return dayjs(date).format(dateFormats.iso)\n  },\n\n  /**\n   * Format a date for API submission\n   */\n  formatForAPI: (date: string | Date | dayjs.Dayjs, includeTime = false) => {\n    const format = includeTime ? dateFormats.apiWithTime : dateFormats.api\n    return dayjs(date).format(format)\n  },\n\n  /**\n   * Parse a date from HTML input\n   */\n  parseFromInput: (dateString: string) => {\n    return dayjs(dateString, dateFormats.iso)\n  },\n\n  /**\n   * Get relative time (e.g., \"2 hours ago\")\n   */\n  getRelativeTime: (date: string | Date | dayjs.Dayjs) => {\n    return dayjs(date).fromNow()\n  },\n\n  /**\n   * Check if a date is valid\n   */\n  isValid: (date: string | Date | dayjs.Dayjs) => {\n    return dayjs(date).isValid()\n  },\n\n  /**\n   * Get today's date in input format\n   */\n  today: () => {\n    return dayjs().format(dateFormats.iso)\n  },\n\n  /**\n   * Get a date N days from now\n   */\n  addDays: (days: number, from?: string | Date | dayjs.Dayjs) => {\n    const baseDate = from ? dayjs(from) : dayjs()\n    return baseDate.add(days, 'day').format(dateFormats.iso)\n  },\n\n  /**\n   * Get age from birth date\n   */\n  getAge: (birthDate: string | Date | dayjs.Dayjs) => {\n    return dayjs().diff(dayjs(birthDate), 'year')\n  },\n}\n\n// Zod schema helpers for date validation\nexport const dateSchemas = {\n  /**\n   * Basic date string validation\n   */\n  dateString: () =>\n    z.string().refine((date) => dateUtils.isValid(date), { message: 'Please enter a valid date' }),\n\n  /**\n   * Date with minimum age requirement\n   */\n  minimumAge: (minAge: number) =>\n    z.string().refine(\n      (date) => {\n        if (!dateUtils.isValid(date)) return false\n        return dateUtils.getAge(date) >= minAge\n      },\n      { message: `You must be at least ${minAge} years old` }\n    ),\n\n  /**\n   * Date within a specific range\n   */\n  dateRange: (minDate?: string, maxDate?: string) =>\n    z.string().refine(\n      (date) => {\n        if (!dateUtils.isValid(date)) return false\n        const d = dayjs(date)\n\n        if (minDate && d.isBefore(dayjs(minDate))) return false\n        if (maxDate && d.isAfter(dayjs(maxDate))) return false\n\n        return true\n      },\n      {\n        message: `Date must be ${minDate ? `after ${dateUtils.formatForDisplay(minDate)}` : ''}${minDate && maxDate ? ' and ' : ''}${maxDate ? `before ${dateUtils.formatForDisplay(maxDate)}` : ''}`,\n      }\n    ),\n\n  /**\n   * Future date only\n   */\n  futureDate: () =>\n    z.string().refine(\n      (date) => {\n        if (!dateUtils.isValid(date)) return false\n        return dayjs(date).isAfter(dayjs(), 'day')\n      },\n      { message: 'Date must be in the future' }\n    ),\n\n  /**\n   * Past date only\n   */\n  pastDate: () =>\n    z.string().refine(\n      (date) => {\n        if (!dateUtils.isValid(date)) return false\n        return dayjs(date).isBefore(dayjs(), 'day')\n      },\n      { message: 'Date must be in the past' }\n    ),\n\n  /**\n   * Business days only (Monday-Friday)\n   */\n  businessDay: () =>\n    z.string().refine(\n      (date) => {\n        if (!dateUtils.isValid(date)) return false\n        const day = dayjs(date).day()\n        return day >= 1 && day <= 5\n      },\n      { message: 'Please select a business day (Monday-Friday)' }\n    ),\n}\n\n// Common date presets for forms\nexport const datePresets = {\n  today: dateUtils.today(),\n  tomorrow: dateUtils.addDays(1),\n  nextWeek: dateUtils.addDays(7),\n  nextMonth: dayjs().add(1, 'month').format(dateFormats.iso),\n\n  // For age restrictions\n  eighteenYearsAgo: dayjs().subtract(18, 'year').format(dateFormats.iso),\n  sixtyFiveYearsAgo: dayjs().subtract(65, 'year').format(dateFormats.iso),\n\n  // Common business dates\n  endOfYear: dayjs().endOf('year').format(dateFormats.iso),\n  startOfYear: dayjs().startOf('year').format(dateFormats.iso),\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/form/types.ts",
      "content": "import * as React from 'react'\nimport {\n  ControllerProps,\n  ControllerRenderProps,\n  FieldPath,\n  FieldValues,\n  PathValue,\n} from 'react-hook-form'\n\n/**\n * Base generic constraints for all form field components\n */\nexport type FormFieldConstraints<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> = {\n  TFieldValues: TFieldValues\n  TName: TName\n}\n\n/**\n * Base props shared by all form field components\n */\nexport interface BaseFormFieldProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> extends Omit<ControllerProps<TFieldValues, TName>, 'render'> {\n  label?: string\n  description?: string\n  className?: string\n}\n\n/**\n * Strongly typed field render function\n */\nexport type FieldRenderFunction<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> = (field: ControllerRenderProps<TFieldValues, TName>) => React.ReactElement\n\n/**\n * Layout render function with proper field typing\n */\nexport type LayoutRenderFunction<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> = (props: {\n  field: ControllerRenderProps<TFieldValues, TName>\n  label?: string\n  description?: string\n  children: React.ReactElement\n}) => React.ReactElement\n\n/**\n * Utility type to extract the field value type from a field path\n */\nexport type FieldValueType<\n  TFieldValues extends FieldValues,\n  TName extends FieldPath<TFieldValues>,\n> = PathValue<TFieldValues, TName>\n\n/**\n * Enhanced input props that properly exclude conflicting properties\n */\nexport type InputPropsExclude<T> = Omit<T, 'name' | 'defaultValue' | 'value' | 'onChange' | 'onBlur'>\n\n/**\n * Type-safe form field component props that extend HTML input props\n * \n * This utility type combines BaseFormFieldProps with HTML input properties while excluding\n * conflicting form control properties (name, value, onChange, etc.) that are managed by React Hook Form.\n * \n * @template TFieldValues - The shape of the entire form data object\n * @template TName - The specific field path within the form data\n * @template TInputProps - The base HTML input props to extend (e.g., HTMLInputElement, HTMLTextAreaElement)\n * \n * @example\n * ```typescript\n * type MyInputProps = TypedFormFieldProps<FormData, 'username', React.InputHTMLAttributes<HTMLInputElement>>\n * ```\n */\nexport type TypedFormFieldProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TInputProps = {},\n> = BaseFormFieldProps<TFieldValues, TName> & InputPropsExclude<TInputProps>",
      "type": "registry:lib"
    }
  ]
}