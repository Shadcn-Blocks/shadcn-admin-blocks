{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "DataTable",
  "type": "registry:block",
  "title": "DataTable",
  "description": "Data table based on TanStack Table.",
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/react-query",
    "@jakub.knejzlik/ts-query",
    "numeral",
    "sql.js",
    "date-fns",
    "dayjs",
    "react-day-picker"
  ],
  "devDependencies": [
    "@types/numeral",
    "@types/sql.js"
  ],
  "registryDependencies": [
    "button",
    "dropdown-menu",
    "select",
    "pagination",
    "table",
    "badge",
    "checkbox",
    "input",
    "popover",
    "scroll-area",
    "skeleton",
    "calendar"
  ],
  "files": [
    {
      "path": "registry/components/data-table/DataTable.tsx",
      "content": "import {\n  ColumnFiltersState,\n  getCoreRowModel,\n  PaginationState,\n  SortingState,\n  useReactTable,\n  VisibilityState,\n} from '@tanstack/react-table'\nimport * as React from 'react'\n\nimport { DataTableActiveFilters } from '@/components/data-table/DataTableActiveFilters'\nimport {\n  DataTableColumn,\n  FilterMetadata,\n  FilterValue,\n  getDefaultFilterType,\n  mapColumn,\n} from '@/components/data-table/DataTableColumn'\nimport { DataTableContent } from '@/components/data-table/DataTableContent'\nimport {\n  DataTableFilterContext,\n  DataTableFilterProvider,\n} from '@/components/data-table/DataTableFilterContext'\nimport { DataTableFilterDropdown } from '@/components/data-table/DataTableFilterDropdown'\nimport { DataTableFooter } from '@/components/data-table/DataTableFooter'\nimport { DataTableProvider } from '@/components/data-table/DataTableProvider'\nimport { FilterMetadataService } from '@/components/data-table/services/FilterMetadataService'\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { Cond, Condition, Fn, Q, SelectQuery } from '@jakub.knejzlik/ts-query'\nimport { useQuery } from '@tanstack/react-query'\n\nexport interface DataTableProps<RecordType> {\n  columns: DataTableColumn<RecordType, any>[]\n  datasource: StaticDataSource\n  query: SelectQuery\n  enableFilters?: boolean\n}\n\n// Helper function to build filter condition from column filter\nconst buildFilterCondition = (\n  column: DataTableColumn<any, any>,\n  filter: any,\n  getFilterValue?: (columnId: string) => FilterValue | undefined\n): Condition | null => {\n  // Get column id - handle both typed columns and regular ColumnDef\n  const columnId =\n    ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || null\n  if (!columnId || !filter) {\n    console.log('buildFilterCondition: No column ID or filter', { columnId, filter })\n    return null\n  }\n\n  // Extract FilterValue from TanStack Table format or global storage\n  let filterValue: FilterValue\n\n  if (typeof filter === 'object' && '_filterValue' in filter) {\n    // Extract our actual FilterValue from the TanStack Table wrapper\n    filterValue = filter._filterValue as FilterValue\n  } else if (typeof filter === 'object' && 'type' in filter) {\n    // Direct FilterValue object\n    filterValue = filter as FilterValue\n  } else if (typeof filter === 'string' && getFilterValue) {\n    // Look up in context storage by column ID\n    const storedFilter = getFilterValue(columnId)\n    if (storedFilter) {\n      filterValue = storedFilter\n    } else {\n      // Fallback: treat as simple value\n      filterValue = { type: 'equals', value: filter }\n    }\n  } else if (typeof filter === 'string') {\n    // Fallback: treat as simple value when no getFilterValue provided\n    filterValue = { type: 'equals', value: filter }\n  } else {\n    // Fallback: treat as simple value\n    filterValue = { type: 'equals', value: filter }\n  }\n  const filterType = ('filterType' in column && column.filterType) || getDefaultFilterType(column)\n\n  console.log('buildFilterCondition:', { columnId, filterType, filterValue })\n\n  switch (filterType) {\n    case 'range':\n      if (filterValue.from !== undefined || filterValue.to !== undefined) {\n        // Convert dates to strings if needed for SQL compatibility\n        const convertValue = (val: any) => {\n          if (val instanceof Date) {\n            return val.toISOString()\n          }\n          if (typeof val === 'string' && val.includes('T') && val.includes('Z')) {\n            // Already ISO string\n            return val\n          }\n          return val\n        }\n\n        const from = filterValue.from ? convertValue(filterValue.from) : null\n        const to = filterValue.to ? convertValue(filterValue.to) : null\n\n        if (from !== null && to !== null) {\n          const condition = Cond.between(columnId, [from, to])\n          console.log('Range filter between:', condition)\n          return condition\n        } else if (from !== null) {\n          const condition = Cond.greaterThanOrEqual(columnId, from)\n          console.log('Range filter >=:', condition)\n          return condition\n        } else if (to !== null) {\n          const condition = Cond.lessThanOrEqual(columnId, to)\n          console.log('Range filter <=:', condition)\n          return condition\n        }\n      }\n      console.log('Range filter: No valid range values')\n      return null\n\n    case 'equals':\n      return filterValue.value !== undefined ? Cond.equal(columnId, filterValue.value) : null\n\n    case 'contains':\n      return filterValue.value ? Cond.like(columnId, `%${filterValue.value}%`) : null\n\n    case 'select':\n      return filterValue.value !== undefined && filterValue.value !== null\n        ? Cond.equal(columnId, filterValue.value)\n        : null\n\n    case 'multi-select':\n      return filterValue.values?.length ? Cond.in(columnId, filterValue.values) : null\n\n    case 'comparison':\n      if (filterValue.value !== undefined && filterValue.operator) {\n        switch (filterValue.operator) {\n          case '>':\n            return Cond.greaterThan(columnId, filterValue.value)\n          case '<':\n            return Cond.lessThan(columnId, filterValue.value)\n          case '>=':\n            return Cond.greaterThanOrEqual(columnId, filterValue.value)\n          case '<=':\n            return Cond.lessThanOrEqual(columnId, filterValue.value)\n          case '!=':\n            return Cond.notEqual(columnId, filterValue.value)\n          default:\n            return Cond.equal(columnId, filterValue.value)\n        }\n      }\n      return null\n\n    case 'toggle':\n      return filterValue.value !== undefined && filterValue.value !== null\n        ? Cond.equal(columnId, filterValue.value)\n        : null\n\n    default:\n      // Fallback for simple value filters\n      if (typeof filter === 'string' || typeof filter === 'number' || typeof filter === 'boolean') {\n        return Cond.equal(columnId, filter)\n      }\n      return null\n  }\n}\n\n// Internal component that uses the filter context\nconst DataTableInner = <RecordType,>({\n  columns,\n  datasource,\n  query,\n  enableFilters = false,\n  children,\n}: React.PropsWithChildren<DataTableProps<RecordType>>) => {\n  const [sorting, setSorting] = React.useState<SortingState>([])\n  const [pagination, setPagination] = React.useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: 10,\n  })\n  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([])\n  const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>({})\n  const [rowSelection, setRowSelection] = React.useState({})\n  const [filterMetadata, setFilterMetadata] = React.useState<Record<string, FilterMetadata>>({})\n  const { getFilterValue } = React.useContext(DataTableFilterContext) || {\n    getFilterValue: () => undefined,\n  }\n\n  // Prefetch metadata for filterable columns\n  React.useEffect(() => {\n    if (!enableFilters) return\n\n    FilterMetadataService.fetchAllMetadata(datasource, query, columns)\n      .then(setFilterMetadata)\n      .catch((error) => {\n        console.warn('Failed to fetch filter metadata:', error)\n      })\n  }, [enableFilters, datasource, query, columns])\n\n  let sourceQuery = query\n\n  // Apply column filters to the query\n  if (columnFilters.length > 0) {\n    const conditions: (Condition | null)[] = columnFilters\n      .map((filter) => {\n        const column = columns.find(\n          (c) =>\n            ('id' in c && c.id === filter.id) ||\n            ('accessorKey' in c && String(c.accessorKey) === filter.id)\n        )\n        if (!column) return null\n        return buildFilterCondition(column, filter.value, getFilterValue)\n      })\n      .filter(Boolean)\n\n    if (conditions.length > 0) {\n      sourceQuery = sourceQuery.where(Cond.and(conditions as Condition[]))\n    }\n  }\n\n  const countQuery = Q.select().addField(Fn.count('*'), 'count').from(sourceQuery)\n\n  if (sorting.length > 0) {\n    for (const sorter of sorting) {\n      sourceQuery = sourceQuery.orderBy(sorter.id, sorter.desc ? 'DESC' : 'ASC')\n    }\n  }\n  sourceQuery = sourceQuery.offset(pagination.pageIndex * pagination.pageSize)\n  sourceQuery = sourceQuery.limit(pagination.pageSize)\n\n  const { data, isFetching } = useQuery({\n    queryKey: ['data-table', datasource.getContentHash(), sourceQuery.toSQL()],\n    queryFn: async () => {\n      // Debug: Log the SQL queries\n      console.log('Data query SQL:', sourceQuery.toSQL())\n      console.log('Count query SQL:', countQuery.toSQL())\n      console.log('Active filters:', columnFilters)\n\n      const [rows, count] = await datasource.executeQueries([sourceQuery, countQuery])\n      return [rows, { count: count[0].count }] as [RecordType[], { count: number }]\n    },\n    placeholderData: (previousData) => previousData,\n  })\n\n  const [_data, count] = data ?? [null, null]\n\n  const table = useReactTable({\n    data: _data ?? [],\n    columns: columns.map((col) =>\n      mapColumn(col, {\n        datasource,\n        query,\n        enableFilters,\n        metadata: filterMetadata,\n        FilterDropdown: DataTableFilterDropdown,\n      })\n    ),\n    manualSorting: true,\n    manualFiltering: true,\n    manualPagination: true,\n    rowCount: count ? count.count : 0,\n    // autoResetPageIndex: true,\n    onSortingChange: setSorting,\n    onColumnFiltersChange: setColumnFilters,\n    onPaginationChange: setPagination,\n    getCoreRowModel: getCoreRowModel(),\n    onColumnVisibilityChange: setColumnVisibility,\n    onRowSelectionChange: setRowSelection,\n    enableRowPinning: true,\n    state: {\n      sorting,\n      columnFilters,\n      columnVisibility,\n      rowSelection,\n      pagination,\n      rowPinning: { bottom: [''], top: [''] },\n      columnPinning: {\n        // left: ['status'],\n        right: ['actions'],\n      },\n    },\n  })\n\n  return (\n    <DataTableProvider table={table} isLoading={isFetching}>\n      <div className=\"w-full\">\n        {children ?? (\n          <>\n            {/* <div className=\"flex items-center py-4\">\n              <DataTableToolbar />\n            </div> */}\n            {enableFilters && columnFilters.length > 0 && (\n              <DataTableActiveFilters columns={columns} />\n            )}\n            <div className=\"rounded-sm border\">\n              <DataTableContent />\n            </div>\n            <div className=\"flex items-center justify-end space-x-2 py-4\">\n              <DataTableFooter />\n            </div>\n          </>\n        )}\n      </div>\n    </DataTableProvider>\n  )\n}\n\n// Export wrapper component that provides the filter context\nexport const DataTable = <RecordType,>(\n  props: React.PropsWithChildren<DataTableProps<RecordType>>\n) => {\n  return (\n    <DataTableFilterProvider>\n      <DataTableInner {...props} />\n    </DataTableFilterProvider>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableColumn.tsx",
      "content": "import { ColumnDef } from '@tanstack/react-table'\nimport { ChevronDownIcon, ChevronsUpDownIcon, ChevronUpIcon } from 'lucide-react'\n\nimport { Button } from '@/components/ui/button'\nimport numeral from 'numeral'\nimport dayjs from 'dayjs'\nimport * as React from 'react'\n\n// Filter type definitions\nexport type FilterType =\n  | 'range' // Works for number AND date\n  | 'equals' // Works for all types\n  | 'contains' // String-specific\n  | 'select' // Dropdown selection (any type)\n  | 'multi-select' // Multiple selection (any type)\n  | 'comparison' // Single value with operator (>, <, etc.)\n  | 'toggle' // Boolean-specific\n  | 'custom' // Custom component\n  | 'none' // No filtering\n\nexport type ComparisonOperator = '=' | '!=' | '>' | '<' | '>=' | '<='\n\nexport interface FilterValue {\n  type: FilterType\n  value?: any\n  from?: any\n  to?: any\n  values?: any[]\n  operator?: ComparisonOperator\n}\n\nexport interface FilterMetadata {\n  // For numeric/date columns\n  min?: number | Date\n  max?: number | Date\n\n  // For string columns\n  distinctValues?: Array<{ value: any; count: number }>\n  totalDistinct?: number\n\n  // For all columns\n  nullCount?: number\n  totalCount?: number\n}\n\nexport interface FilterOptions {\n  // For select/multi-select\n  options?: Array<{ label: string; value: any }>\n\n  // For number ranges\n  min?: number\n  max?: number\n  step?: number\n\n  // For date ranges\n  minDate?: Date\n  maxDate?: Date\n\n  // For text filters\n  caseSensitive?: boolean\n\n  // Custom filter render\n  renderFilter?: (props: any) => React.ReactNode\n\n  // Presets for quick filtering\n  presets?: Array<{\n    label: string\n    value: any\n  }>\n}\n\n// Base column type with filter properties - using intersection type instead of extends\ntype DataTableColumnBase<Data, Value = unknown> = ColumnDef<Data, Value> & {\n  id?: string\n  title?: React.ReactNode\n  filterable?: boolean\n  filterType?: FilterType\n  filterOptions?: FilterOptions\n}\n\nexport type DataTableColumnString<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'string'\n}\nexport type DataTableColumnNumber<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'number'\n  format?: string // e.g. '0,0.00' for 1,000.00\n}\nexport type DataTableColumnDate<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'date'\n}\nexport type DataTableColumnBoolean<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'boolean'\n}\nexport type DataTableColumnActions<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'actions'\n}\n\nexport type DataTableColumn<Data, Value = unknown> =\n  | DataTableColumnString<Data, Value>\n  | DataTableColumnNumber<Data, Value>\n  | DataTableColumnDate<Data, Value>\n  | DataTableColumnBoolean<Data, Value>\n  | DataTableColumnActions<Data, Value>\n  | ColumnDef<Data, Value>\n\n// Helper function to get default filter type based on column type\nexport const getDefaultFilterType = (column: DataTableColumn<any, any>): FilterType => {\n  if (!('type' in column)) return 'equals'\n\n  switch (column.type) {\n    case 'string':\n      return 'contains'\n    case 'number':\n    case 'date':\n      return 'range'\n    case 'boolean':\n      return 'toggle'\n    case 'actions':\n      return 'none'\n    default:\n      return 'equals'\n  }\n}\n\n// Context for passing additional data to mapColumn\nexport interface MapColumnContext {\n  datasource?: any\n  query?: any\n  metadata?: FilterMetadata\n  enableFilters?: boolean\n  FilterDropdown?: React.ComponentType<any>\n}\n\nexport const mapColumn = <Data, Value>(\n  column: DataTableColumn<Data, Value>,\n  context?: MapColumnContext\n): ColumnDef<Data, Value> => {\n  const res: ColumnDef<Data, Value> = {\n    header: ({ column: tableColumn }) => {\n      const FilterDropdown = context?.FilterDropdown\n\n      return (\n        <div className=\"flex items-center justify-center gap-0.5\">\n          <Button\n            variant=\"ghost\"\n            onClick={({ shiftKey }) => {\n              tableColumn.getIsSorted() === 'desc'\n                ? tableColumn.clearSorting()\n                : tableColumn.toggleSorting(tableColumn.getIsSorted() === 'asc', shiftKey)\n            }}\n            className=\"h-auto py-1 pr-1\"\n          >\n            <span className=\"flex items-center gap-1\">\n              {('title' in column && column.title) ||\n                ('id' in column && column.id) ||\n                ('accessorKey' in column && String(column.accessorKey)) ||\n                'Column'}\n              {!tableColumn.getIsSorted() && <ChevronsUpDownIcon className=\"h-4 w-4\" />}\n              {tableColumn.getIsSorted() === 'asc' && <ChevronUpIcon className=\"h-4 w-4\" />}\n              {tableColumn.getIsSorted() === 'desc' && <ChevronDownIcon className=\"h-4 w-4\" />}\n            </span>\n          </Button>\n          {context?.enableFilters &&\n            FilterDropdown &&\n            ('filterable' in column && column.filterable !== false) &&\n            (!('type' in column) || column.type !== 'actions') && (\n              <FilterDropdown\n                column={column}\n                datasource={context.datasource}\n                query={context.query}\n                metadata={\n                  context.metadata?.[\n                    (('id' in column && column.id) ||\n                      ('accessorKey' in column && String(column.accessorKey)) ||\n                      '') as keyof FilterMetadata\n                  ] as any\n                }\n                value={tableColumn.getFilterValue()}\n                onChange={(value: any) => {\n                  console.log('DataTableColumn: Setting filter value for', tableColumn.id, {\n                    value,\n                    currentValue: tableColumn.getFilterValue(),\n                  })\n\n                  // Use a simple primitive value that TanStack Table will accept\n                  let tanstackValue: any = null\n\n                  if (value && typeof value === 'object' && 'type' in value) {\n                    const filterId = `${tableColumn.id}_${Date.now()}`\n                    // Use a simple string that TanStack Table will accept\n                    tanstackValue = filterId\n                  }\n\n                  tableColumn.setFilterValue(tanstackValue)\n                  console.log(\n                    'DataTableColumn: Filter value set, new value:',\n                    tableColumn.getFilterValue()\n                  )\n                }}\n              />\n            )}\n        </div>\n      )\n    },\n    ...column,\n  }\n  if (!('type' in column)) {\n    return res\n  }\n\n  switch (column.type) {\n    case 'string':\n      return {\n        ...res,\n      }\n    case 'number':\n      return {\n        size: 100,\n        cell: ({ getValue }) => (\n          <div className={`text-right`}>\n            {numeral(getValue()).format(column.format ?? '0,0.00')}\n          </div>\n        ),\n        ...res,\n      }\n    case 'date':\n      return {\n        ...res,\n        cell: ({ getValue }) => {\n          const value = getValue()\n          if (value === null || value === undefined || value === '') {\n            return <div className=\"text-center text-muted-foreground\">-</div>\n          }\n          const date = dayjs(value as any)\n          if (!date.isValid()) {\n            return <div className=\"text-center text-muted-foreground\">-</div>\n          }\n          return <div className=\"text-center\">{date.format('DD.MM.YYYY HH:mm:ss')}</div>\n        },\n      }\n    case 'boolean':\n      return {\n        ...res,\n      }\n    case 'actions':\n      return {\n        // Let the column auto-size based on content\n        // This will adapt to 1 button (~40px) or 2 buttons (~80px)\n        ...res,\n      }\n    default:\n      return res\n  }\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableContent.tsx",
      "content": "import { flexRender } from '@tanstack/react-table'\n\nimport type { Column } from '@tanstack/react-table'\n\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table'\nimport { CSSProperties } from 'react'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\n\nconst getCommonPinningStyles = (column: Column<any>): CSSProperties => {\n  const isPinned = column.getIsPinned()\n  const isLastLeftPinnedColumn = isPinned === 'left' && column.getIsLastColumn('left')\n  const isFirstRightPinnedColumn = isPinned === 'right' && column.getIsFirstColumn('right')\n\n  return {\n    boxShadow: isLastLeftPinnedColumn\n      ? '-2px 0 4px -2px gray inset'\n      : isFirstRightPinnedColumn\n        ? '3px 0 3px -3px gray inset'\n        : undefined,\n    left: isPinned === 'left' ? `${column.getStart('left')}px` : undefined,\n    right: isPinned === 'right' ? `${column.getAfter('right')}px` : undefined,\n    // opacity: isPinned ? 1 : 1,\n    position: isPinned ? 'sticky' : 'relative',\n    width: column.getSize(),\n    zIndex: isPinned ? 1 : 0,\n  }\n}\n\nexport const DataTableContent = <RecordType,>() => {\n  const { table, isLoading } = useDataTable<RecordType>()\n  const hasRows = table.getRowModel().rows?.length > 0\n  \n  // Don't show \"No results\" if we're loading and have no data yet\n  // This prevents the flash of \"No results\" during pagination\n  const showNoResults = !hasRows && !isLoading\n  \n  return (\n    <div className=\"relative\">\n      <Table>\n        <TableHeader>\n          {table.getHeaderGroups().map((headerGroup) => (\n            <TableRow key={headerGroup.id}>\n              {headerGroup.headers.map((header) => {\n                const { column } = header\n                return (\n                  <TableHead key={header.id} style={{ ...getCommonPinningStyles(column) }}>\n                    {header.isPlaceholder\n                      ? null\n                      : flexRender(header.column.columnDef.header, header.getContext())}\n                  </TableHead>\n                )\n              })}\n            </TableRow>\n          ))}\n        </TableHeader>\n        <TableBody>\n          {hasRows ? (\n            table.getRowModel().rows.map((row) => (\n              <TableRow key={row.id} data-state={row.getIsSelected() && 'selected'}>\n                {row.getVisibleCells().map((cell) => (\n                  <TableCell\n                    key={cell.id}\n                    style={{ ...getCommonPinningStyles(cell.column), width: 0 }}\n                  >\n                    {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                  </TableCell>\n                ))}\n              </TableRow>\n            ))\n          ) : showNoResults ? (\n            <TableRow>\n              <TableCell colSpan={table.getAllColumns().length} className=\"h-24 text-center\">\n                No results.\n              </TableCell>\n            </TableRow>\n          ) : (\n            // Show empty body during loading to maintain table height\n            <TableRow>\n              <TableCell colSpan={table.getAllColumns().length} className=\"h-24\">\n                &nbsp;\n              </TableCell>\n            </TableRow>\n          )}\n        </TableBody>\n      </Table>\n      {isLoading && (\n        <div \n          className=\"absolute inset-x-0 bottom-0 flex items-center justify-center bg-background/50 backdrop-blur-sm rounded-b\"\n          style={{ top: `${table.getHeaderGroups().length * 52}px` }}\n        >\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width={24}\n            height={24}\n            viewBox=\"0 0 24 24\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            className=\"animate-spin text-primary\"\n          >\n            <path d=\"M21 12a9 9 0 1 1-6.219-8.56\" />\n          </svg>\n        </div>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableFooter.tsx",
      "content": "'use client'\n\nimport { DataTablePageSwitcher } from '@/components/data-table/DataTablePageSwitcher'\nimport { DataTablePagination } from '@/components/data-table/DataTablePagination'\n\nexport function DataTableFooter() {\n  return (\n    <div className=\"flex items-center justify-between px-2 text-sm\">\n      <DataTablePagination />\n      <div className=\"flex items-center space-x-6 lg:space-x-8\">\n        <div className=\"flex items-center space-x-2\">\n          <DataTablePageSwitcher />\n        </div>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTablePageSwitcher.tsx",
      "content": "'use client'\n\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\n\nexport function DataTablePageSwitcher<TData>() {\n  const { table } = useDataTable<TData>()\n\n  return (\n    <Select\n      value={`${table.getState().pagination.pageSize}`}\n      onValueChange={(value) => {\n        table.setPageSize(Number(value))\n      }}\n    >\n      <SelectTrigger className=\"h-8 w-[120px]\" size=\"sm\">\n        <SelectValue placeholder={table.getState().pagination.pageSize} />\n      </SelectTrigger>\n      <SelectContent side=\"top\">\n        {[10, 20, 30, 40, 50].map((pageSize) => (\n          <SelectItem key={pageSize} value={`${pageSize}`}>\n            {pageSize} / page\n          </SelectItem>\n        ))}\n      </SelectContent>\n    </Select>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTablePagination.tsx",
      "content": "'use client'\n\nimport {\n  Pagination,\n  PaginationContent,\n  PaginationEllipsis,\n  PaginationItem,\n  PaginationLink,\n  PaginationNext,\n  PaginationPrevious,\n} from '@/components/ui/pagination'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\n\n// Constants for pagination display logic\nconst MAX_VISIBLE_PAGES_WITHOUT_ELLIPSIS = 7\nconst SIBLING_COUNT = 1 // Pages to show on each side of current page\n\n// Type for pagination items\ntype PageItem = number | 'ellipsis-start' | 'ellipsis-end'\n\nexport function DataTablePagination<TData>() {\n  const { table } = useDataTable<TData>()\n  const currentPage = table.getState().pagination.pageIndex + 1\n  const totalPages = table.getPageCount()\n\n  // Helper function to create a range of page numbers\n  const createPageRange = (start: number, end: number): number[] => {\n    const pages: number[] = []\n    for (let i = start; i <= end; i++) {\n      pages.push(i)\n    }\n    return pages\n  }\n\n  // Determine which pages should be visible in the pagination\n  const getVisiblePages = (): PageItem[] => {\n    // Show all pages if total is small enough\n    if (totalPages <= MAX_VISIBLE_PAGES_WITHOUT_ELLIPSIS) {\n      return createPageRange(1, totalPages)\n    }\n\n    const pages: PageItem[] = []\n    \n    // Special handling for edge cases to show the next/previous page\n    // When on pages 1-2, show page 3; when on page 3, show page 4\n    // When on last 2 pages, show 3rd from last; when on 3rd from last, show 4th from last\n    \n    // Near the beginning (pages 1-3)\n    if (currentPage <= 3) {\n      // Determine how many pages to show at the start\n      let endPage = 3 // Default: show 1, 2, 3\n      if (currentPage === 3 && totalPages > 4) {\n        endPage = 4 // On page 3, also show page 4\n      } else if (currentPage <= 2 && totalPages > 3) {\n        endPage = 3 // On pages 1-2, show up to page 3\n      }\n      \n      pages.push(...createPageRange(1, Math.min(endPage, totalPages)))\n      \n      if (endPage < totalPages - 1) {\n        pages.push('ellipsis-end')\n        pages.push(totalPages)\n      } else if (endPage < totalPages) {\n        pages.push(totalPages)\n      }\n      \n      return pages\n    }\n    \n    // Near the end (last 3 pages)\n    if (currentPage >= totalPages - 2) {\n      let startPage = totalPages - 2 // Default: show last 3 pages\n      if (currentPage === totalPages - 2 && totalPages > 4) {\n        startPage = totalPages - 3 // On 3rd from last, also show 4th from last\n      } else if (currentPage >= totalPages - 1 && totalPages > 3) {\n        startPage = totalPages - 2 // On last 2 pages, show last 3 pages\n      }\n      \n      pages.push(1)\n      \n      if (startPage > 2) {\n        pages.push('ellipsis-start')\n      } else if (startPage === 2) {\n        // No ellipsis needed, just add page 2\n      }\n      \n      pages.push(...createPageRange(Math.max(startPage, 2), totalPages))\n      \n      return pages\n    }\n    \n    // In the middle - show current page and siblings\n    pages.push(1)\n    \n    const leftSibling = currentPage - SIBLING_COUNT\n    const rightSibling = currentPage + SIBLING_COUNT\n    \n    if (leftSibling > 2) {\n      pages.push('ellipsis-start')\n    }\n    \n    pages.push(...createPageRange(\n      Math.max(2, leftSibling),\n      Math.min(totalPages - 1, rightSibling)\n    ))\n    \n    if (rightSibling < totalPages - 1) {\n      pages.push('ellipsis-end')\n    }\n    \n    pages.push(totalPages)\n    \n    return pages\n  }\n\n  // Event handlers\n  const handlePreviousClick = (e: React.MouseEvent) => {\n    e.preventDefault()\n    if (table.getCanPreviousPage()) {\n      table.previousPage()\n    }\n  }\n\n  const handleNextClick = (e: React.MouseEvent) => {\n    e.preventDefault()\n    if (table.getCanNextPage()) {\n      table.nextPage()\n    }\n  }\n\n  const handlePageClick = (pageNumber: number) => (e: React.MouseEvent) => {\n    e.preventDefault()\n    table.setPageIndex(pageNumber - 1)\n  }\n\n  // Render helpers\n  const renderPageItem = (page: PageItem, index: number) => {\n    if (page === 'ellipsis-start' || page === 'ellipsis-end') {\n      return (\n        <PaginationItem key={`${page}-${index}`}>\n          <PaginationEllipsis />\n        </PaginationItem>\n      )\n    }\n\n    return (\n      <PaginationItem key={page}>\n        <PaginationLink\n          href=\"#\"\n          onClick={handlePageClick(page)}\n          isActive={currentPage === page}\n          className=\"cursor-pointer\"\n        >\n          {page}\n        </PaginationLink>\n      </PaginationItem>\n    )\n  }\n\n  const visiblePages = getVisiblePages()\n  const canGoPrevious = table.getCanPreviousPage()\n  const canGoNext = table.getCanNextPage()\n\n  return (\n    <Pagination>\n      <PaginationContent>\n        <PaginationItem>\n          <PaginationPrevious\n            href=\"#\"\n            onClick={handlePreviousClick}\n            className={\n              !canGoPrevious \n                ? 'pointer-events-none opacity-50' \n                : 'cursor-pointer'\n            }\n          />\n        </PaginationItem>\n\n        {visiblePages.map((page, index) => renderPageItem(page, index))}\n\n        <PaginationItem>\n          <PaginationNext\n            href=\"#\"\n            onClick={handleNextClick}\n            className={\n              !canGoNext \n                ? 'pointer-events-none opacity-50' \n                : 'cursor-pointer'\n            }\n          />\n        </PaginationItem>\n      </PaginationContent>\n    </Pagination>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableProvider.tsx",
      "content": "import { useReactTable } from '@tanstack/react-table'\nimport * as React from 'react'\n\ninterface DataTableContextValue<RecordType> {\n  table: ReturnType<typeof useReactTable<RecordType>>\n  isLoading?: boolean\n}\n\nconst DataTableContext = React.createContext<DataTableContextValue<any> | undefined>(undefined)\n\nexport function DataTableProvider<RecordType>({\n  table,\n  isLoading,\n  children,\n}: React.PropsWithChildren<{ \n  table: ReturnType<typeof useReactTable<RecordType>>\n  isLoading?: boolean \n}>) {\n  return <DataTableContext.Provider value={{ table, isLoading }}>{children}</DataTableContext.Provider>\n}\n\nexport function useDataTable<RecordType>() {\n  const context = React.useContext(DataTableContext)\n  if (!context) {\n    throw new Error('useDataTable must be used within a DataTableProvider')\n  }\n  return context as DataTableContextValue<RecordType>\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableToolbar.tsx",
      "content": "import { ChevronDown } from 'lucide-react'\n\nimport { Button } from '@/components/ui/button'\nimport {\n  DropdownMenu,\n  DropdownMenuCheckboxItem,\n  DropdownMenuContent,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\n\nexport const DataTableToolbar = <RecordType,>() => {\n  const { table } = useDataTable<RecordType>()\n  return (\n    <div className=\"flex items-center py-4\">\n      <DropdownMenu>\n        <DropdownMenuTrigger asChild>\n          <Button variant=\"outline\" className=\"ml-auto\">\n            Columns <ChevronDown />\n          </Button>\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"end\">\n          {table\n            .getAllColumns()\n            .filter((column) => column.getCanHide())\n            .map((column) => {\n              return (\n                <DropdownMenuCheckboxItem\n                  key={column.id}\n                  className=\"capitalize\"\n                  checked={column.getIsVisible()}\n                  onCheckedChange={(value) => column.toggleVisibility(!!value)}\n                >\n                  {column.id}\n                </DropdownMenuCheckboxItem>\n              )\n            })}\n        </DropdownMenuContent>\n      </DropdownMenu>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableActiveFilters.tsx",
      "content": "import { X } from 'lucide-react'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\nimport { DataTableColumn } from '@/components/data-table/DataTableColumn'\nimport dayjs from 'dayjs'\n\ninterface DataTableActiveFiltersProps<TData> {\n  columns: DataTableColumn<TData, any>[]\n}\n\nexport function DataTableActiveFilters<TData>({ columns }: DataTableActiveFiltersProps<TData>) {\n  const { table } = useDataTable()\n  const columnFilters = table.getState().columnFilters\n  \n  if (columnFilters.length === 0) {\n    return null\n  }\n  \n  const getFilterLabel = (columnId: string, value: any): string => {\n    const column = columns.find(c => \n      ('id' in c && c.id === columnId) || \n      ('accessorKey' in c && String(c.accessorKey) === columnId)\n    )\n    \n    if (!column) return `${columnId}: ${JSON.stringify(value)}`\n    \n    const columnName = ('id' in column && column.id) || \n                      ('accessorKey' in column && String(column.accessorKey)) || \n                      'Unknown'\n    \n    // Handle different filter value types\n    if (value?.from !== undefined || value?.to !== undefined) {\n      const from = value.from ?? 'min'\n      const to = value.to ?? 'max'\n      \n      if ('type' in column && column.type === 'date') {\n        const fromStr = value.from ? dayjs(value.from).format('MMM D') : 'start'\n        const toStr = value.to ? dayjs(value.to).format('MMM D') : 'end'\n        return `${columnName}: ${fromStr} to ${toStr}`\n      }\n      \n      return `${columnName}: ${from} to ${to}`\n    }\n    \n    if (value?.value !== undefined) {\n      return `${columnName}: ${value.value}`\n    }\n    \n    if (value?.values?.length > 0) {\n      return `${columnName}: ${value.values.length} selected`\n    }\n    \n    // Fallback for simple values\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n      return `${columnName}: ${value}`\n    }\n    \n    return `${columnName}: filtered`\n  }\n  \n  const clearFilter = (columnId: string) => {\n    table.getColumn(columnId)?.setFilterValue(undefined)\n  }\n  \n  const clearAllFilters = () => {\n    table.resetColumnFilters()\n  }\n  \n  return (\n    <div className=\"flex items-center gap-2 p-2 border-b bg-muted/30\">\n      <span className=\"text-sm font-medium text-muted-foreground\">Active filters:</span>\n      <div className=\"flex flex-wrap gap-2\">\n        {columnFilters.map((filter) => (\n          <Badge\n            key={filter.id}\n            variant=\"secondary\"\n            className=\"pr-1.5 text-xs font-normal\"\n          >\n            {getFilterLabel(filter.id, filter.value)}\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"ml-1 h-auto p-0 hover:bg-transparent\"\n              onClick={() => clearFilter(filter.id)}\n              aria-label={`Clear filter for ${filter.id}`}\n            >\n              <X className=\"h-3 w-3\" />\n            </Button>\n          </Badge>\n        ))}\n      </div>\n      <Button\n        variant=\"ghost\"\n        size=\"sm\"\n        onClick={clearAllFilters}\n        className=\"ml-auto text-xs\"\n      >\n        Clear all\n      </Button>\n    </div>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableFilterContext.tsx",
      "content": "import * as React from 'react'\nimport { FilterValue } from '@/components/data-table/DataTableColumn'\n\ninterface DataTableFilterContextValue {\n  filterValues: Record<string, FilterValue>\n  setFilterValue: (columnId: string, value: FilterValue | null) => void\n  getFilterValue: (columnId: string) => FilterValue | undefined\n}\n\nexport const DataTableFilterContext = React.createContext<DataTableFilterContextValue | undefined>(undefined)\n\nexport const useDataTableFilters = () => {\n  const context = React.useContext(DataTableFilterContext)\n  if (!context) {\n    throw new Error('useDataTableFilters must be used within DataTableFilterProvider')\n  }\n  return context\n}\n\nexport const DataTableFilterProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [filterValues, setFilterValues] = React.useState<Record<string, FilterValue>>({})\n\n  const setFilterValue = React.useCallback((columnId: string, value: FilterValue | null) => {\n    setFilterValues(prev => {\n      if (value === null) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { [columnId]: _, ...rest } = prev\n        return rest\n      }\n      return {\n        ...prev,\n        [columnId]: value\n      }\n    })\n  }, [])\n\n  const getFilterValue = React.useCallback((columnId: string) => {\n    return filterValues[columnId]\n  }, [filterValues])\n\n  return (\n    <DataTableFilterContext.Provider value={{ filterValues, setFilterValue, getFilterValue }}>\n      {children}\n    </DataTableFilterContext.Provider>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableFilterDropdown.tsx",
      "content": "import * as React from 'react'\nimport { FilterIcon } from 'lucide-react'\nimport { Button } from '@/components/ui/button'\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'\nimport { DataTableColumn, FilterValue, FilterMetadata, getDefaultFilterType } from '@/components/data-table/DataTableColumn'\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { SelectQuery } from '@jakub.knejzlik/ts-query'\nimport { RangeFilter } from './filters/RangeFilter'\nimport { TextFilter } from './filters/TextFilter'\nimport { ToggleFilter } from './filters/ToggleFilter'\nimport { DateRangeFilter } from './filters/DateRangeFilter'\nimport { MultiSelectFilter } from './filters/MultiSelectFilter'\nimport { cn } from '@/lib/utils'\nimport { DataTableFilterContext } from '@/components/data-table/DataTableFilterContext'\n\nexport interface DataTableFilterDropdownProps {\n  column: DataTableColumn<any, any>\n  datasource?: StaticDataSource\n  query?: SelectQuery\n  metadata?: FilterMetadata\n  value?: any\n  onChange: (value: any) => void\n}\n\nexport const DataTableFilterDropdown: React.FC<DataTableFilterDropdownProps> = ({\n  column,\n  datasource,\n  query,\n  metadata,\n  value,\n  onChange\n}) => {\n  const [open, setOpen] = React.useState(false)\n  // Use context if available, but don't fail if not\n  const filterContext = React.useContext(DataTableFilterContext)\n  \n  // Extract FilterValue from TanStack Table format or context storage\n  const extractFilterValue = React.useCallback((val: any): FilterValue | null => {\n    if (!val) return null\n    \n    // If it's already our format, return it\n    if (typeof val === 'object' && 'type' in val && !('_filterValue' in val)) {\n      return val as FilterValue\n    }\n    \n    // If it's the TanStack Table wrapper format, extract our data\n    if (typeof val === 'object' && '_filterValue' in val) {\n      return val._filterValue as FilterValue\n    }\n    \n    // If it's a string (from our new approach), look up in context storage\n    if (typeof val === 'string') {\n      const columnId = ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey))\n      if (columnId && filterContext) {\n        return filterContext.getFilterValue(columnId) || null\n      }\n    }\n    \n    return null\n  }, [column, filterContext])\n  \n  const [localValue, setLocalValue] = React.useState(() => extractFilterValue(value))\n  \n  // Update local value when prop changes\n  React.useEffect(() => {\n    setLocalValue(extractFilterValue(value))\n  }, [value, extractFilterValue])\n  \n  // Check if column is filterable\n  const isFilterable = ('filterable' in column ? column.filterable !== false : true) && \n    (!('type' in column) || column.type !== 'actions')\n  \n  if (!isFilterable) {\n    return null\n  }\n\n  const filterType = ('filterType' in column ? column.filterType : null) || getDefaultFilterType(column)\n  \n  // Don't show filter for 'none' type\n  if (filterType === 'none') {\n    return null\n  }\n\n  // Check if filter has a value\n  const actualValue = extractFilterValue(value)\n  const hasFilter = actualValue && (\n    (actualValue.value !== undefined) || \n    (actualValue.from !== undefined) || \n    (actualValue.to !== undefined) || \n    (actualValue.values && actualValue.values.length > 0)\n  )\n\n  const handleFilterChange = (newValue: FilterValue | null) => {\n    const columnId = ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey))\n    console.log('DataTableFilterDropdown: Filter value changed:', { column: columnId, newValue })\n    setLocalValue(newValue)\n    \n    // Store in context if available\n    if (columnId && filterContext) {\n      if (newValue) {\n        filterContext.setFilterValue(columnId, newValue)\n      } else {\n        filterContext.setFilterValue(columnId, null)\n      }\n    }\n    \n    onChange(newValue)\n    // Close popover after applying filter\n    if (newValue !== null) {\n      setOpen(false)\n    }\n  }\n\n  const renderFilterComponent = () => {\n    // Use DateRangeFilter for date columns with range filter\n    if ('type' in column && column.type === 'date' && filterType === 'range') {\n      return (\n        <DateRangeFilter\n          column={column}\n          datasource={datasource}\n          query={query}\n          value={localValue || undefined}\n          onChange={handleFilterChange}\n          isOpen={open}\n        />\n      )\n    }\n\n    switch (filterType) {\n      case 'range':\n        return (\n          <RangeFilter\n            column={column}\n            datasource={datasource}\n            query={query}\n            value={localValue || undefined}\n            onChange={handleFilterChange}\n            isOpen={open}\n          />\n        )\n      \n      case 'contains':\n      case 'equals':\n        return (\n          <TextFilter\n            column={column}\n            datasource={datasource}\n            query={query}\n            value={localValue || undefined}\n            onChange={handleFilterChange}\n            isOpen={open}\n          />\n        )\n      \n      case 'select':\n        return (\n          <TextFilter\n            column={column}\n            datasource={datasource}\n            query={query}\n            value={localValue || undefined}\n            onChange={handleFilterChange}\n            isOpen={open}\n          />\n        )\n      \n      case 'multi-select':\n        return (\n          <MultiSelectFilter\n            column={column}\n            datasource={datasource}\n            query={query}\n            value={localValue || undefined}\n            onChange={handleFilterChange}\n            isOpen={open}\n          />\n        )\n      \n      case 'toggle':\n        return (\n          <ToggleFilter\n            column={column}\n            value={localValue || undefined}\n            onChange={handleFilterChange}\n          />\n        )\n      \n      case 'custom':\n        if ('filterOptions' in column && column.filterOptions?.renderFilter) {\n          return column.filterOptions.renderFilter({\n            column,\n            datasource,\n            query,\n            metadata,\n            value: localValue,\n            onChange: handleFilterChange\n          })\n        }\n        return null\n      \n      default:\n        return (\n          <div className=\"p-3 text-sm text-muted-foreground\">\n            Filter type \"{filterType}\" not implemented yet\n          </div>\n        )\n    }\n  }\n\n  // Get column name for accessibility\n  const columnName = ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || 'column'\n  \n  // Get filter description for screen readers\n  const getFilterDescription = () => {\n    if (!hasFilter || !actualValue) return ''\n    if (actualValue.from !== undefined || actualValue.to !== undefined) {\n      return `Range: ${actualValue.from || 'min'} to ${actualValue.to || 'max'}`\n    }\n    if (actualValue.value !== undefined) {\n      return `Value: ${actualValue.value}`\n    }\n    if (actualValue.values && actualValue.values.length > 0) {\n      return `${actualValue.values.length} values selected`\n    }\n    return 'Active'\n  }\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          className={cn(\n            \"h-8 w-8 p-0 relative group\",\n            \"md:h-8 md:w-8\", // Desktop size\n            \"touch:h-10 touch:w-10\", // Mobile touch target\n            hasFilter && \"text-primary\"\n          )}\n          aria-label={`Filter ${columnName}${hasFilter ? ` (${getFilterDescription()})` : ''}`}\n          aria-expanded={open}\n          aria-haspopup=\"dialog\"\n          title={`Filter ${columnName}`}\n        >\n          <FilterIcon className={cn(\n            \"h-4 w-4 transition-all\",\n            \"group-hover:h-[18px] group-hover:w-[18px]\",\n            hasFilter && \"h-[18px] w-[18px] fill-primary\"\n          )} />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent \n        align=\"start\" \n        className=\"w-auto p-0\"\n        onInteractOutside={(e) => {\n          // Prevent closing when clicking date picker calendar\n          const target = e.target as HTMLElement\n          if (target.closest('[role=\"dialog\"]')) {\n            e.preventDefault()\n          }\n        }}\n      >\n        {renderFilterComponent()}\n      </PopoverContent>\n    </Popover>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/filters/DateRangeFilter.tsx",
      "content": "import * as React from 'react'\nimport { X } from 'lucide-react'\nimport { DateRange } from 'react-day-picker'\nimport { DataTableColumn, FilterValue, FilterMetadata } from '@/components/data-table/DataTableColumn'\nimport { DateRangePicker } from '@/components/form/DateRangePicker'\nimport { Button } from '@/components/ui/button'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { SelectQuery } from '@jakub.knejzlik/ts-query'\nimport { FilterMetadataService } from '@/components/data-table/services/FilterMetadataService'\nimport { parseFilterValue, toFilterValue, DATE_PRESETS } from '@/lib/date-range-utils'\nimport dayjs from 'dayjs'\nimport { useQuery } from '@tanstack/react-query'\n\nexport interface DateRangeFilterProps {\n  column: DataTableColumn<any, any>\n  datasource?: StaticDataSource\n  query?: SelectQuery\n  value?: FilterValue\n  onChange: (value: FilterValue | null) => void\n  isOpen?: boolean\n}\n\nexport const DateRangeFilter: React.FC<DateRangeFilterProps> = ({\n  column,\n  datasource,\n  query,\n  value,\n  onChange,\n  isOpen = false\n}) => {\n  const [dateRange, setDateRange] = React.useState<DateRange | undefined>(\n    parseFilterValue(value)\n  )\n\n  // Get column id for query key\n  const columnId = ('id' in column && column.id) || \n    ('accessorKey' in column && String(column.accessorKey)) || 'unknown'\n\n  // Use React Query for metadata fetching\n  const { data: metadata = {} as FilterMetadata, isLoading: loading } = useQuery<FilterMetadata>({\n    queryKey: ['filter-metadata', query?.toSQL(), columnId],\n    queryFn: async () => {\n      if (!datasource || !query) return {} as FilterMetadata\n      return FilterMetadataService.fetchMetadata(datasource, query, column)\n    },\n    // Enable query when dropdown is open or when we have existing values\n    enabled: !!datasource && !!query && (isOpen || (!!value && (!!value.from || !!value.to))),\n    staleTime: 5 * 60 * 1000, // Consider data stale after 5 minutes\n    gcTime: 10 * 60 * 1000, // Keep in cache for 10 minutes\n  })\n\n  React.useEffect(() => {\n    setDateRange(parseFilterValue(value))\n  }, [value])\n\n  const handleDateRangeChange = (range: DateRange | undefined) => {\n    setDateRange(range)\n  }\n\n  const handleApply = () => {\n    onChange(toFilterValue(dateRange))\n  }\n\n  const handleClear = () => {\n    setDateRange(undefined)\n    onChange(null)\n  }\n\n  const handlePreset = (preset: () => DateRange) => {\n    const range = preset()\n    setDateRange(range)\n    onChange(toFilterValue(range))\n  }\n\n  if (loading) {\n    return (\n      <div className=\"space-y-2 p-4 min-w-[320px]\">\n        <Skeleton className=\"h-4 w-full\" />\n        <Skeleton className=\"h-10 w-full\" />\n        <Skeleton className=\"h-[280px] w-full\" />\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"p-4 min-w-[320px] max-w-[640px]\">\n      <div className=\"flex items-center justify-between mb-3\">\n        <div className=\"text-sm font-medium\">Select date range</div>\n        {dateRange && (dateRange.from || dateRange.to) && (\n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            onClick={handleClear}\n            className=\"h-7 px-2 text-xs\"\n          >\n            <X className=\"h-3 w-3 mr-1\" />\n            Clear\n          </Button>\n        )}\n      </div>\n\n      <div className=\"grid grid-cols-2 gap-2 mb-4\">\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          className=\"justify-start h-8 text-xs\"\n          onClick={() => handlePreset(DATE_PRESETS.today)}\n        >\n          Today\n        </Button>\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          className=\"justify-start h-8 text-xs\"\n          onClick={() => handlePreset(DATE_PRESETS.yesterday)}\n        >\n          Yesterday\n        </Button>\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          className=\"justify-start h-8 text-xs\"\n          onClick={() => handlePreset(DATE_PRESETS.last7Days)}\n        >\n          Last 7 days\n        </Button>\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          className=\"justify-start h-8 text-xs\"\n          onClick={() => handlePreset(DATE_PRESETS.last30Days)}\n        >\n          Last 30 days\n        </Button>\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          className=\"justify-start h-8 text-xs\"\n          onClick={() => handlePreset(DATE_PRESETS.thisMonth)}\n        >\n          This month\n        </Button>\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          className=\"justify-start h-8 text-xs\"\n          onClick={() => handlePreset(DATE_PRESETS.lastMonth)}\n        >\n          Last month\n        </Button>\n      </div>\n\n      <DateRangePicker\n        value={dateRange}\n        onChange={handleDateRangeChange}\n        className=\"w-full h-10 mb-3\"\n        minDate={metadata?.min ? dayjs(metadata.min).startOf('day').toDate() : undefined}\n        maxDate={metadata?.max ? dayjs(metadata.max).endOf('day').toDate() : undefined}\n        placeholder=\"Pick a date range\"\n      />\n\n      {metadata && (metadata.min !== undefined || metadata.max !== undefined) && (\n        <div className=\"text-xs text-muted-foreground mb-3\">\n          Data range: {metadata.min ? dayjs(metadata.min).format('MMM D, YYYY') : '...'} \n          {' - '}\n          {metadata.max ? dayjs(metadata.max).format('MMM D, YYYY') : '...'}\n          {metadata.nullCount && metadata.nullCount > 0 && (\n            <span className=\"ml-1\">({metadata.nullCount} empty values)</span>\n          )}\n        </div>\n      )}\n\n      <Button\n        onClick={handleApply}\n        className=\"w-full\"\n        disabled={!dateRange?.from && !dateRange?.to}\n      >\n        Apply Date Range\n      </Button>\n    </div>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/filters/MultiSelectFilter.tsx",
      "content": "import * as React from 'react'\nimport { X, Search } from 'lucide-react'\nimport { DataTableColumn, FilterValue, FilterMetadata } from '@/components/data-table/DataTableColumn'\nimport { Button } from '@/components/ui/button'\nimport { Checkbox } from '@/components/ui/checkbox'\nimport { Input } from '@/components/ui/input'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport { ScrollArea } from '@/components/ui/scroll-area'\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { SelectQuery } from '@jakub.knejzlik/ts-query'\nimport { FilterMetadataService } from '@/components/data-table/services/FilterMetadataService'\nimport { cn } from '@/lib/utils'\nimport { useQuery } from '@tanstack/react-query'\n\nexport interface MultiSelectFilterProps {\n  column: DataTableColumn<any, any>\n  datasource?: StaticDataSource\n  query?: SelectQuery\n  value?: FilterValue\n  onChange: (value: FilterValue | null) => void\n  isOpen?: boolean\n}\n\nexport const MultiSelectFilter: React.FC<MultiSelectFilterProps> = ({\n  column,\n  datasource,\n  query,\n  value,\n  onChange,\n  isOpen = false\n}) => {\n  const [searchTerm, setSearchTerm] = React.useState('')\n  const [selectedValues, setSelectedValues] = React.useState<Set<string>>(\n    new Set(value?.values || [])\n  )\n\n  // Get column id for query key\n  const columnId = ('id' in column && column.id) || \n    ('accessorKey' in column && String(column.accessorKey)) || 'unknown'\n\n  // Use React Query for metadata fetching\n  const { data: metadata = {} as FilterMetadata, isLoading: loading } = useQuery<FilterMetadata>({\n    queryKey: ['filter-metadata', query?.toSQL(), columnId],\n    queryFn: async () => {\n      if (!datasource || !query) return {} as FilterMetadata\n      return FilterMetadataService.fetchMetadata(datasource, query, column)\n    },\n    // Enable query when dropdown is open or when we have existing values\n    enabled: !!datasource && !!query && (isOpen || (!!value?.values && value.values.length > 0)),\n    staleTime: 5 * 60 * 1000, // Consider data stale after 5 minutes\n    gcTime: 10 * 60 * 1000, // Keep in cache for 10 minutes (formerly cacheTime)\n  })\n\n  // Update selected values when prop changes\n  React.useEffect(() => {\n    setSelectedValues(new Set(value?.values || []))\n  }, [value])\n\n  const handleToggleValue = (val: string) => {\n    const newSelected = new Set(selectedValues)\n    if (newSelected.has(val)) {\n      newSelected.delete(val)\n    } else {\n      newSelected.add(val)\n    }\n    setSelectedValues(newSelected)\n  }\n\n  const handleSelectAll = () => {\n    if (metadata?.distinctValues) {\n      setSelectedValues(new Set(metadata.distinctValues.map(item => item.value || '__empty__')))\n    }\n  }\n\n  const handleClear = () => {\n    setSelectedValues(new Set())\n    onChange(null)\n  }\n\n  const handleApply = () => {\n    if (selectedValues.size === 0) {\n      onChange(null)\n    } else {\n      const values = Array.from(selectedValues).map(v => v === '__empty__' ? '' : v)\n      onChange({\n        type: 'multi-select',\n        values\n      })\n    }\n  }\n\n  if (loading) {\n    return (\n      <div className=\"space-y-2 p-4 min-w-[280px]\">\n        <Skeleton className=\"h-4 w-20\" />\n        <Skeleton className=\"h-9 w-full\" />\n        <div className=\"space-y-2\">\n          <Skeleton className=\"h-8 w-full\" />\n          <Skeleton className=\"h-8 w-full\" />\n          <Skeleton className=\"h-8 w-full\" />\n        </div>\n      </div>\n    )\n  }\n\n  const filteredValues = metadata?.distinctValues?.filter(item => {\n    const value = item.value || '(empty)'\n    return value.toLowerCase().includes(searchTerm.toLowerCase())\n  }) || []\n\n  const columnName = ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || 'field'\n\n  return (\n    <div className=\"p-4 min-w-[300px] max-w-[400px]\">\n      {/* Header with Clear button */}\n      <div className=\"flex items-center justify-between mb-3\">\n        <div className=\"text-sm font-medium\">\n          Select {columnName} values\n        </div>\n        {selectedValues.size > 0 && (\n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            onClick={handleClear}\n            className=\"h-7 px-2 text-xs\"\n          >\n            <X className=\"h-3 w-3 mr-1\" />\n            Clear all\n          </Button>\n        )}\n      </div>\n\n      {/* Search input */}\n      {filteredValues.length > 5 && (\n        <div className=\"relative mb-3\">\n          <Search className=\"absolute left-2 top-2.5 h-4 w-4 text-muted-foreground\" />\n          <Input\n            placeholder=\"Search values...\"\n            value={searchTerm}\n            onChange={(e) => setSearchTerm(e.target.value)}\n            className=\"h-9 pl-8\"\n          />\n        </div>\n      )}\n\n      {/* Quick actions */}\n      <div className=\"flex gap-2 mb-3\">\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          onClick={handleSelectAll}\n          className=\"h-7 text-xs flex-1\"\n        >\n          Select all ({metadata?.distinctValues?.length || 0})\n        </Button>\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          onClick={() => setSelectedValues(new Set())}\n          className=\"h-7 text-xs flex-1\"\n        >\n          Deselect all\n        </Button>\n      </div>\n\n      {/* Selected count */}\n      {selectedValues.size > 0 && (\n        <div className=\"text-xs text-muted-foreground mb-2\">\n          {selectedValues.size} of {metadata?.distinctValues?.length || 0} selected\n        </div>\n      )}\n\n      {/* Values list */}\n      <ScrollArea className=\"h-[200px] border rounded-md p-2 mb-3\">\n        {filteredValues.length === 0 ? (\n          <div className=\"text-sm text-muted-foreground text-center py-4\">\n            No matching values\n          </div>\n        ) : (\n          <div className=\"space-y-1\">\n            {filteredValues.map((item) => {\n              const itemValue = item.value || '__empty__'\n              const isSelected = selectedValues.has(itemValue)\n              return (\n                <div\n                  key={itemValue}\n                  className={cn(\n                    \"flex items-center space-x-2 p-2 rounded-md cursor-pointer transition-colors\",\n                    \"hover:bg-accent\",\n                    isSelected && \"bg-accent\"\n                  )}\n                  onClick={() => handleToggleValue(itemValue)}\n                >\n                  <Checkbox\n                    checked={isSelected}\n                    onCheckedChange={() => handleToggleValue(itemValue)}\n                    onClick={(e) => e.stopPropagation()}\n                  />\n                  <div className=\"flex-1 flex items-center justify-between\">\n                    <span className=\"text-sm\">\n                      {item.value || '(empty)'}\n                    </span>\n                    <span className=\"text-xs text-muted-foreground\">\n                      {item.count}\n                    </span>\n                  </div>\n                </div>\n              )\n            })}\n          </div>\n        )}\n      </ScrollArea>\n\n      {/* Info about null values */}\n      {metadata?.nullCount && metadata.nullCount > 0 && (\n        <div className=\"text-xs text-muted-foreground mb-3\">\n          {metadata.nullCount} empty values in data\n        </div>\n      )}\n\n      {/* Action button */}\n      <Button\n        onClick={handleApply}\n        className=\"w-full\"\n        disabled={selectedValues.size === 0}\n      >\n        Apply Filter ({selectedValues.size} selected)\n      </Button>\n    </div>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/filters/RangeFilter.tsx",
      "content": "import * as React from 'react'\nimport { X } from 'lucide-react'\nimport { DataTableColumn, FilterValue, FilterMetadata } from '@/components/data-table/DataTableColumn'\nimport { Input } from '@/components/ui/input'\nimport { Button } from '@/components/ui/button'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { SelectQuery } from '@jakub.knejzlik/ts-query'\nimport { FilterMetadataService } from '@/components/data-table/services/FilterMetadataService'\nimport numeral from 'numeral'\nimport { useQuery } from '@tanstack/react-query'\n\nexport interface RangeFilterProps {\n  column: DataTableColumn<any, any>\n  datasource?: StaticDataSource\n  query?: SelectQuery\n  value?: FilterValue\n  onChange: (value: FilterValue | null) => void\n  isOpen?: boolean\n}\n\nexport const RangeFilter: React.FC<RangeFilterProps> = ({\n  column,\n  datasource,\n  query,\n  value,\n  onChange,\n  isOpen = false\n}) => {\n  const [localValue, setLocalValue] = React.useState<{ from?: any; to?: any }>({\n    from: value?.from,\n    to: value?.to\n  })\n\n  // This component now only handles number ranges\n  // Date ranges are handled by DateRangeFilter\n  const isNumber = 'type' in column && column.type === 'number'\n\n  // Get column id for query key\n  const columnId = ('id' in column && column.id) || \n    ('accessorKey' in column && String(column.accessorKey)) || 'unknown'\n\n  // Use React Query for metadata fetching\n  const { data: metadata = {} as FilterMetadata, isLoading: loading } = useQuery<FilterMetadata>({\n    queryKey: ['filter-metadata', query?.toSQL(), columnId],\n    queryFn: async () => {\n      if (!datasource || !query) return {} as FilterMetadata\n      return FilterMetadataService.fetchMetadata(datasource, query, column)\n    },\n    // Enable query when dropdown is open or when we have existing values\n    enabled: !!datasource && !!query && (isOpen || (!!value && (value.from !== undefined || value.to !== undefined))),\n    staleTime: 5 * 60 * 1000, // Consider data stale after 5 minutes\n    gcTime: 10 * 60 * 1000, // Keep in cache for 10 minutes\n  })\n\n  // Update local value when prop changes\n  React.useEffect(() => {\n    setLocalValue({\n      from: value?.from,\n      to: value?.to\n    })\n  }, [value])\n\n  const handleApply = () => {\n    if (!localValue.from && !localValue.to) {\n      onChange(null)\n    } else {\n      onChange({\n        type: 'range',\n        from: localValue.from,\n        to: localValue.to\n      })\n    }\n  }\n\n  const handleClear = () => {\n    setLocalValue({ from: undefined, to: undefined })\n    onChange(null)\n  }\n\n  const formatValue = (val: any) => {\n    if (val === null || val === undefined) return ''\n    if (isNumber && column.type === 'number' && column.format) {\n      return numeral(val).format(column.format)\n    }\n    return String(val)\n  }\n\n  if (loading) {\n    return (\n      <div className=\"space-y-2 p-3 min-w-[280px]\">\n        <Skeleton className=\"h-4 w-full\" />\n        <div className=\"flex gap-2\">\n          <Skeleton className=\"h-9 w-full\" />\n          <Skeleton className=\"h-9 w-full\" />\n        </div>\n        <Skeleton className=\"h-8 w-full\" />\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-3 p-3 min-w-[280px]\">\n      {/* Header with Clear button */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"text-sm font-medium\">Set range</div>\n        {(localValue.from !== undefined || localValue.to !== undefined) && (\n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            onClick={handleClear}\n            className=\"h-7 px-2 text-xs\"\n          >\n            <X className=\"h-3 w-3 mr-1\" />\n            Clear\n          </Button>\n        )}\n      </div>\n\n      {/* Range info */}\n      {metadata && (metadata.min !== undefined || metadata.max !== undefined) && (\n        <div className=\"text-xs text-muted-foreground\">\n          Data range: {formatValue(metadata.min)} - {formatValue(metadata.max)}\n          {metadata.totalCount && (\n            <span className=\"ml-1\">({metadata.totalCount} records)</span>\n          )}\n        </div>\n      )}\n\n      {/* Range inputs */}\n      <div className=\"flex gap-2\">\n        <Input\n          type=\"number\"\n          placeholder={`Min${metadata?.min !== undefined ? ` (${formatValue(metadata.min)})` : ''}`}\n          value={localValue.from ?? ''}\n          onChange={(e) => setLocalValue({ \n            ...localValue, \n            from: e.target.value ? Number(e.target.value) : undefined \n          })}\n          min={metadata?.min as number}\n          max={metadata?.max as number}\n          step={'filterOptions' in column && column.filterOptions ? column.filterOptions.step : undefined}\n          className=\"flex-1\"\n        />\n        <Input\n          type=\"number\"\n          placeholder={`Max${metadata?.max !== undefined ? ` (${formatValue(metadata.max)})` : ''}`}\n          value={localValue.to ?? ''}\n          onChange={(e) => setLocalValue({ \n            ...localValue, \n            to: e.target.value ? Number(e.target.value) : undefined \n          })}\n          min={localValue.from || (metadata?.min as number)}\n          max={metadata?.max as number}\n          step={'filterOptions' in column && column.filterOptions ? column.filterOptions.step : undefined}\n          className=\"flex-1\"\n        />\n      </div>\n\n\n\n      {/* Custom presets from column options */}\n      {'filterOptions' in column && column.filterOptions?.presets && (\n        <div className=\"flex gap-1 flex-wrap\">\n          {column.filterOptions.presets.map((preset: any, index: number) => (\n            <Button\n              key={index}\n              size=\"sm\"\n              variant=\"outline\"\n              className=\"h-7 text-xs\"\n              onClick={() => {\n                if (preset.value && typeof preset.value === 'object') {\n                  setLocalValue(preset.value)\n                }\n              }}\n            >\n              {preset.label}\n            </Button>\n          ))}\n        </div>\n      )}\n\n      {/* Action button */}\n      <div className=\"pt-2 border-t\">\n        <Button\n          size=\"sm\"\n          onClick={handleApply}\n          className=\"w-full font-medium min-h-[36px] md:min-h-[32px] touch:min-h-[44px]\"\n        >\n          Apply Filter\n        </Button>\n      </div>\n    </div>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/filters/TextFilter.tsx",
      "content": "import * as React from 'react'\nimport { Search, X } from 'lucide-react'\nimport { DataTableColumn, FilterValue, FilterMetadata } from '@/components/data-table/DataTableColumn'\nimport { Input } from '@/components/ui/input'\nimport { Button } from '@/components/ui/button'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { SelectQuery } from '@jakub.knejzlik/ts-query'\nimport { FilterMetadataService } from '@/components/data-table/services/FilterMetadataService'\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select'\nimport { useQuery } from '@tanstack/react-query'\n\nexport interface TextFilterProps {\n  column: DataTableColumn<any, any>\n  datasource?: StaticDataSource\n  query?: SelectQuery\n  value?: FilterValue\n  onChange: (value: FilterValue | null) => void\n  isOpen?: boolean\n}\n\nexport const TextFilter: React.FC<TextFilterProps> = ({\n  column,\n  datasource,\n  query,\n  value,\n  onChange,\n  isOpen = false\n}) => {\n  const [mode, setMode] = React.useState<'select' | 'search'>('search')\n  const [searchValue, setSearchValue] = React.useState(value?.value || '')\n  const [filterType, setFilterType] = React.useState<'contains' | 'equals'>(\n    value?.type === 'equals' ? 'equals' : 'contains'\n  )\n\n  // Get column id for query key\n  const columnId = ('id' in column && column.id) || \n    ('accessorKey' in column && String(column.accessorKey)) || 'unknown'\n\n  // Use React Query for metadata fetching\n  const { data: metadata = {} as FilterMetadata, isLoading: loading } = useQuery<FilterMetadata>({\n    queryKey: ['filter-metadata', query?.toSQL(), columnId],\n    queryFn: async () => {\n      if (!datasource || !query) return {} as FilterMetadata\n      const data = await FilterMetadataService.fetchMetadata(datasource, query, column)\n      // Auto-switch to select mode if few distinct values\n      if ((data.totalDistinct || 0) <= 10 && data.distinctValues) {\n        setMode('select')\n      }\n      return data\n    },\n    // Enable query when dropdown is open or when we have existing values\n    enabled: !!datasource && !!query && (isOpen || value?.value !== undefined),\n    staleTime: 5 * 60 * 1000, // Consider data stale after 5 minutes\n    gcTime: 10 * 60 * 1000, // Keep in cache for 10 minutes\n  })\n\n  // Update search value when prop changes\n  React.useEffect(() => {\n    setSearchValue(value?.value || '')\n  }, [value])\n\n  const handleApply = () => {\n    if (!searchValue) {\n      onChange(null)\n    } else {\n      onChange({\n        type: filterType,\n        value: searchValue\n      })\n    }\n  }\n\n  const handleSelectValue = (selectedValue: string) => {\n    if (selectedValue === '__all__') {\n      onChange(null)\n    } else {\n      onChange({\n        type: 'equals',\n        value: selectedValue === '__empty__' ? '' : selectedValue\n      })\n    }\n  }\n\n  const handleClear = () => {\n    setSearchValue('')\n    onChange(null)\n  }\n\n  if (loading) {\n    return (\n      <div className=\"space-y-2 p-3 min-w-[280px]\">\n        <Skeleton className=\"h-4 w-20\" />\n        <Skeleton className=\"h-9 w-full\" />\n        <Skeleton className=\"h-8 w-full\" />\n      </div>\n    )\n  }\n\n  // If we have few distinct values, show select mode\n  const showSelectMode = metadata && \n    metadata.totalDistinct !== undefined && \n    metadata.totalDistinct <= 10 &&\n    metadata.distinctValues &&\n    metadata.distinctValues.length > 0\n\n  if (showSelectMode && mode === 'select') {\n    return (\n      <div className=\"space-y-3 p-3 min-w-[280px]\">\n        {/* Header with Clear button */}\n        <div className=\"flex items-center justify-between\">\n          <div className=\"text-xs text-muted-foreground\">\n            Select a value ({metadata.totalDistinct} unique)\n          </div>\n          {value?.value && (\n            <Button\n              size=\"sm\"\n              variant=\"ghost\"\n              onClick={handleClear}\n              className=\"h-7 px-2 text-xs\"\n            >\n              <X className=\"h-3 w-3 mr-1\" />\n              Clear\n            </Button>\n          )}\n        </div>\n        \n        <Select\n          value={value?.value === '' ? '__empty__' : (value?.value || '__all__')}\n          onValueChange={handleSelectValue}\n        >\n          <SelectTrigger className=\"w-full\">\n            <SelectValue placeholder=\"Select a value\" />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"__all__\">\n              All ({metadata.totalCount} records)\n            </SelectItem>\n            {metadata.distinctValues?.map((item: any) => (\n              <SelectItem \n                key={item.value || '__empty__'} \n                value={item.value || '__empty__'}\n              >\n                <div className=\"flex items-center justify-between w-full\">\n                  <span>{item.value || '(empty)'}</span>\n                  <span className=\"ml-2 text-xs text-muted-foreground\">\n                    ({item.count})\n                  </span>\n                </div>\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n        \n        {/* Option to switch to search mode */}\n        <Button\n          size=\"sm\"\n          variant=\"outline\"\n          className=\"w-full\"\n          onClick={() => setMode('search')}\n        >\n          <Search className=\"mr-2 h-4 w-4\" />\n          Switch to search\n        </Button>\n      </div>\n    )\n  }\n\n  // Search mode\n  return (\n    <div className=\"space-y-3 p-3 min-w-[280px]\">\n      {/* Header with Clear button */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"text-xs text-muted-foreground\">\n          {metadata?.totalDistinct !== undefined && (\n            <>\n              {metadata.totalDistinct} unique values\n              {showSelectMode && (\n                <Button\n                  size=\"sm\"\n                  variant=\"ghost\"\n                  className=\"ml-2 h-auto p-0 text-xs\"\n                  onClick={() => setMode('select')}\n                >\n                  Show list\n                </Button>\n              )}\n            </>\n          )}\n        </div>\n        {searchValue && (\n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            onClick={handleClear}\n            className=\"h-7 px-2 text-xs\"\n          >\n            <X className=\"h-3 w-3 mr-1\" />\n            Clear\n          </Button>\n        )}\n      </div>\n\n      {/* Search input */}\n      <div className=\"space-y-2\">\n        <Input\n          placeholder={`Search ${('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || 'field'}...`}\n          value={searchValue}\n          onChange={(e) => setSearchValue(e.target.value)}\n          onKeyDown={(e) => {\n            if (e.key === 'Enter') {\n              handleApply()\n            }\n          }}\n          className=\"h-9\"\n        />\n        \n        {/* Filter type selector */}\n        <div className=\"flex gap-1\">\n          <Button\n            size=\"sm\"\n            variant={filterType === 'contains' ? 'default' : 'outline'}\n            onClick={() => setFilterType('contains')}\n            className=\"flex-1 h-8\"\n          >\n            Contains\n          </Button>\n          <Button\n            size=\"sm\"\n            variant={filterType === 'equals' ? 'default' : 'outline'}\n            onClick={() => setFilterType('equals')}\n            className=\"flex-1 h-8\"\n          >\n            Exact match\n          </Button>\n        </div>\n      </div>\n\n      {/* Action button */}\n      <div className=\"pt-2 border-t\">\n        <Button\n          size=\"sm\"\n          onClick={handleApply}\n          className=\"w-full font-medium min-h-[36px] md:min-h-[32px] touch:min-h-[44px]\"\n        >\n          Apply Filter\n        </Button>\n      </div>\n    </div>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/filters/ToggleFilter.tsx",
      "content": "import * as React from 'react'\nimport { DataTableColumn, FilterValue } from '@/components/data-table/DataTableColumn'\nimport { Button } from '@/components/ui/button'\nimport { Check } from 'lucide-react'\nimport { cn } from '@/lib/utils'\n\nexport interface ToggleFilterProps {\n  column: DataTableColumn<any, any>\n  value?: FilterValue\n  onChange: (value: FilterValue | null) => void\n}\n\nexport const ToggleFilter: React.FC<ToggleFilterProps> = ({\n  column,\n  value,\n  onChange\n}) => {\n  const [selectedValue, setSelectedValue] = React.useState<boolean | null>(\n    value?.value ?? null\n  )\n\n  // Update selected value when prop changes\n  React.useEffect(() => {\n    setSelectedValue(value?.value ?? null)\n  }, [value])\n\n  const handleSelect = (newValue: boolean | null) => {\n    setSelectedValue(newValue)\n    if (newValue === null) {\n      onChange(null)\n    } else {\n      onChange({\n        type: 'toggle',\n        value: newValue\n      })\n    }\n  }\n\n  return (\n    <div className=\"p-3 min-w-[200px] space-y-2\">\n      <div className=\"text-xs text-muted-foreground mb-2\">\n        Filter by {('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || 'field'}\n      </div>\n      \n      <div className=\"space-y-1\">\n        <Button\n          variant={selectedValue === null ? 'default' : 'outline'}\n          size=\"sm\"\n          className=\"w-full justify-start\"\n          onClick={() => handleSelect(null)}\n        >\n          <Check className={cn(\n            \"mr-2 h-4 w-4\",\n            selectedValue === null ? \"opacity-100\" : \"opacity-0\"\n          )} />\n          All\n        </Button>\n        \n        <Button\n          variant={selectedValue === true ? 'default' : 'outline'}\n          size=\"sm\"\n          className=\"w-full justify-start\"\n          onClick={() => handleSelect(true)}\n        >\n          <Check className={cn(\n            \"mr-2 h-4 w-4\",\n            selectedValue === true ? \"opacity-100\" : \"opacity-0\"\n          )} />\n          True\n        </Button>\n        \n        <Button\n          variant={selectedValue === false ? 'default' : 'outline'}\n          size=\"sm\"\n          className=\"w-full justify-start\"\n          onClick={() => handleSelect(false)}\n        >\n          <Check className={cn(\n            \"mr-2 h-4 w-4\",\n            selectedValue === false ? \"opacity-100\" : \"opacity-0\"\n          )} />\n          False\n        </Button>\n      </div>\n\n      {selectedValue !== null && (\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"w-full mt-2\"\n          onClick={() => handleSelect(null)}\n        >\n          Clear filter\n        </Button>\n      )}\n    </div>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/services/FilterMetadataCache.ts",
      "content": "import { FilterMetadata } from '@/components/data-table/DataTableColumn'\n\ninterface CacheEntry {\n  data: FilterMetadata\n  timestamp: number\n}\n\nexport class FilterMetadataCache {\n  private cache = new Map<string, CacheEntry>()\n  private TTL: number\n  private pendingRequests = new Map<string, Promise<FilterMetadata>>()\n\n  constructor(ttlInMinutes: number = 5) {\n    this.TTL = ttlInMinutes * 60 * 1000\n  }\n\n  /**\n   * Get cached metadata or fetch it using the provided fetcher\n   * Prevents duplicate requests for the same key\n   */\n  async get(\n    key: string,\n    fetcher: () => Promise<FilterMetadata>\n  ): Promise<FilterMetadata> {\n    // Check if there's already a pending request for this key\n    const pending = this.pendingRequests.get(key)\n    if (pending) {\n      return pending\n    }\n\n    // Check cache\n    const cached = this.cache.get(key)\n    if (cached && Date.now() - cached.timestamp < this.TTL) {\n      return cached.data\n    }\n\n    // Create new request and store it as pending\n    const request = fetcher()\n      .then(data => {\n        // Cache the result\n        this.cache.set(key, { data, timestamp: Date.now() })\n        return data\n      })\n      .finally(() => {\n        // Remove from pending requests\n        this.pendingRequests.delete(key)\n      })\n\n    this.pendingRequests.set(key, request)\n    return request\n  }\n\n  /**\n   * Clear specific cache entry\n   */\n  invalidate(key: string): void {\n    this.cache.delete(key)\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear(): void {\n    this.cache.clear()\n    // Cancel all pending requests by clearing the map\n    this.pendingRequests.clear()\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): { size: number; pendingRequests: number } {\n    return {\n      size: this.cache.size,\n      pendingRequests: this.pendingRequests.size\n    }\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup(): void {\n    const now = Date.now()\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp >= this.TTL) {\n        this.cache.delete(key)\n      }\n    }\n  }\n}\n\n// Singleton instance for the application\nexport const filterMetadataCache = new FilterMetadataCache()",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/services/FilterMetadataService.ts",
      "content": "import { Fn, Q, SelectQuery, Cond } from '@jakub.knejzlik/ts-query'\nimport { DataTableColumn, FilterMetadata } from '@/components/data-table/DataTableColumn'\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { filterMetadataCache } from './FilterMetadataCache'\n\nexport class FilterMetadataService {\n  /**\n   * Fetch metadata for a specific column with caching\n   */\n  static async fetchMetadata(\n    datasource: StaticDataSource,\n    baseQuery: SelectQuery,\n    column: DataTableColumn<any, any>\n  ): Promise<FilterMetadata> {\n    // Get column id - handle both typed columns and regular ColumnDef\n    const columnId = ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || 'unknown'\n    \n    // Generate cache key\n    const cacheKey = `${baseQuery.toSQL()}_${columnId}`\n\n    // Use cache with fetcher\n    return filterMetadataCache.get(cacheKey, async () => {\n      return this.fetchMetadataUncached(datasource, baseQuery, column)\n    })\n  }\n\n  /**\n   * Fetch metadata without caching (internal use)\n   */\n  private static async fetchMetadataUncached(\n    datasource: StaticDataSource,\n    baseQuery: SelectQuery,\n    column: DataTableColumn<any, any>\n  ): Promise<FilterMetadata> {\n    // Get column id - handle both typed columns and regular ColumnDef\n    const columnId = ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || null\n    \n    if (!columnId) {\n      return {}\n    }\n\n    const queries: SelectQuery[] = []\n    const metadata: FilterMetadata = {}\n\n    // Determine column type\n    const columnType = 'type' in column ? column.type : 'unknown'\n\n    switch (columnType) {\n      case 'number':\n      case 'date':\n        // Get min/max values and counts\n        queries.push(\n          Q.select()\n            .addField(Fn.min(columnId), 'min')\n            .addField(Fn.max(columnId), 'max')\n            .addField(Fn.count(columnId), 'nonNullCount')\n            .addField(Fn.count('*'), 'totalCount')\n            .from(baseQuery)\n        )\n        break\n\n      case 'string':\n        // Get distinct values with counts (limited to 100 for performance)\n        queries.push(\n          Q.select()\n            .addField(columnId, 'value')\n            .addField(Fn.count('*'), 'count')\n            .from(baseQuery)\n            .where(Cond.notNull(columnId))\n            .groupBy(columnId)\n            .orderBy(Fn.count('*'), 'DESC')\n            .limit(100)\n        )\n\n        // Get total distinct count separately\n        // Note: countDistinct might not be available, using COUNT(DISTINCT col) pattern\n        queries.push(\n          Q.select()\n            .addField(Q.raw(`COUNT(DISTINCT ${columnId})`), 'totalDistinct')\n            .addField(Fn.count('*'), 'totalCount')\n            .from(baseQuery)\n        )\n        break\n\n      case 'boolean':\n        // Get true/false/null counts\n        queries.push(\n          Q.select()\n            .addField(columnId, 'value')\n            .addField(Fn.count('*'), 'count')\n            .from(baseQuery)\n            .groupBy(columnId)\n        )\n\n        // Get total count\n        queries.push(Q.select().addField(Fn.count('*'), 'totalCount').from(baseQuery))\n        break\n\n      default:\n        // For unknown types, just get basic counts\n        queries.push(\n          Q.select()\n            .addField(Fn.count(columnId), 'nonNullCount')\n            .addField(Fn.count('*'), 'totalCount')\n            .from(baseQuery)\n        )\n    }\n\n    // Execute all queries\n    try {\n      const results = await datasource.executeQueries(queries)\n\n      // Process results based on column type\n      switch (columnType) {\n        case 'number':\n        case 'date':\n          if (results[0] && results[0][0]) {\n            const row = results[0][0]\n            metadata.min = row.min\n            metadata.max = row.max\n            metadata.totalCount = row.totalCount\n            metadata.nullCount = row.totalCount - row.nonNullCount\n          }\n          break\n\n        case 'string':\n          if (results[0]) {\n            metadata.distinctValues = results[0].map((row: any) => ({\n              value: row.value,\n              count: row.count,\n            }))\n          }\n          if (results[1] && results[1][0]) {\n            metadata.totalDistinct = results[1][0].totalDistinct\n            metadata.totalCount = results[1][0].totalCount\n          }\n          break\n\n        case 'boolean':\n          if (results[0]) {\n            metadata.distinctValues = results[0].map((row: any) => ({\n              value: row.value,\n              count: row.count,\n            }))\n          }\n          if (results[1] && results[1][0]) {\n            metadata.totalCount = results[1][0].totalCount\n          }\n          break\n\n        default:\n          if (results[0] && results[0][0]) {\n            const row = results[0][0]\n            metadata.totalCount = row.totalCount\n            metadata.nullCount = row.totalCount - row.nonNullCount\n          }\n      }\n    } catch (error) {\n      console.warn(`Failed to fetch metadata for column ${columnId}:`, error)\n      // Return empty metadata on error\n      return {}\n    }\n\n    return metadata\n  }\n\n  /**\n   * Fetch metadata for multiple columns in parallel\n   */\n  static async fetchAllMetadata(\n    datasource: StaticDataSource,\n    baseQuery: SelectQuery,\n    columns: DataTableColumn<any, any>[]\n  ): Promise<Record<string, FilterMetadata>> {\n    const metadata: Record<string, FilterMetadata> = {}\n\n    // Filter out non-filterable columns\n    const filterableColumns = columns.filter((col) => {\n      if (!('type' in col)) return false\n      if (col.type === 'actions') return false\n      if (col.filterable === false) return false\n      return true\n    })\n\n    // Fetch metadata in parallel\n    const promises = filterableColumns.map(async (column) => {\n      const columnId = ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || null\n      if (!columnId) return\n      try {\n        const columnMetadata = await this.fetchMetadata(datasource, baseQuery, column)\n        metadata[columnId] = columnMetadata\n      } catch (error) {\n        console.warn(`Failed to fetch metadata for ${columnId}:`, error)\n        metadata[columnId] = {}\n      }\n    })\n\n    await Promise.all(promises)\n    return metadata\n  }\n\n  /**\n   * Clear cache for a specific query/column combination\n   */\n  static invalidateCache(baseQuery: SelectQuery, columnId?: string): void {\n    if (columnId) {\n      const cacheKey = `${baseQuery.toSQL()}_${columnId}`\n      filterMetadataCache.invalidate(cacheKey)\n    } else {\n      // If no columnId specified, clear all cache\n      filterMetadataCache.clear()\n    }\n  }\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/StaticDataTable.tsx",
      "content": "import * as React from 'react'\n\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { Q } from '@jakub.knejzlik/ts-query'\nimport { DataTable, DataTableProps } from '@/components/data-table/DataTable'\n\ntype RowType = Record<string, any>\n\ninterface StaticDataTableProps<RecordType extends RowType>\n  extends Omit<DataTableProps<RecordType>, 'datasource' | 'query'> {\n  data: RecordType[]\n}\n\nexport const StaticDataTable = <RecordType extends RowType>({\n  data,\n  ...rest\n}: React.PropsWithChildren<StaticDataTableProps<RecordType>>) => {\n  const datasource = React.useMemo(() => new StaticDataSource({ table: data }), [data])\n\n  return (\n    <DataTable<RecordType> datasource={datasource} query={Q.select().from('table')} {...rest} />\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/lib/data-sources/database-metadata.ts",
      "content": "import { Database } from 'sql.js'\n// import { Resource } from './models/Resource';\nimport dayjs from 'dayjs'\n\nexport type StaticDataType =\n  | 'TEXT'\n  | 'REAL'\n  | 'INTEGER PRIMARY KEY AUTOINCREMENT'\n  | 'INTEGER'\n  | 'BLOB'\n  | 'DATETIME'\n  | 'EMPTY_TEXT'\n\nexport type StaticDataTable = Record<string, any>[]\nexport type StaticDataTables = { [key: string]: StaticDataTable }\n\nexport type StaticDatabaseMetadataTableColumn = {\n  name: string\n  label: string\n  type: StaticDataType\n}\nexport type StaticDatabaseMetadataTable = {\n  columns: StaticDatabaseMetadataTableColumn[]\n}\nexport type StaticDatabaseMetadata = {\n  tables: Record<string, StaticDatabaseMetadataTable>\n}\n\nexport type StaticDatabase = {\n  tables: StaticDataTables\n  database: Database\n  metadata: StaticDatabaseMetadata\n}\n\nexport type createDatabaseMetadataOpts = {\n  tables: StaticDataTables\n  enforcePrimaryID?: boolean\n  overrideColumnMapping?: Partial<Record<StaticDataType, StaticDataType>>\n}\n\nexport const createDatabaseMetadata = ({\n  tables,\n  enforcePrimaryID,\n  overrideColumnMapping,\n}: createDatabaseMetadataOpts): StaticDatabaseMetadata => {\n  return {\n    tables: Object.keys(tables).reduce(\n      (result, tableName) => {\n        result[tableName] = {\n          columns: Object.keys(tables[tableName]?.[0] ?? {}).map((col, i) => {\n            const type = dataTypeForColumn(col, tables[tableName] ?? [], enforcePrimaryID ?? false)\n            return {\n              name:\n                col\n                  .normalize('NFD')\n                  .replace(/[\\u0300-\\u036f]/g, '')\n                  .replace(/\\s|[^\\w]/g, '_') || `column_${i}`,\n              label: col,\n              type: overrideColumnMapping?.[type] || type,\n            }\n          }),\n        }\n        return result\n      },\n      {} as Record<string, StaticDatabaseMetadataTable>\n    ),\n  }\n}\n\nexport const dataTypeForColumn = (\n  columnName: string,\n  tableData: StaticDataTable,\n  enforcePrimaryID: boolean\n): StaticDataType => {\n  if (columnName === 'id' && enforcePrimaryID) return 'INTEGER PRIMARY KEY AUTOINCREMENT'\n  const firstNCount = 500\n  const values = tableData.slice(0, firstNCount).map((item) => item[columnName])\n  const types = new Set<StaticDataType>()\n  for (const value of values) {\n    const type = dataTypeForColumnForValue(value)\n    if (type !== null) {\n      types.add(type)\n    }\n  }\n\n  if (types.size > 1) {\n    if (types.has('EMPTY_TEXT') && types.has('DATETIME')) {\n      return 'DATETIME'\n    }\n    if (types.has('TEXT')) {\n      return 'TEXT'\n    }\n    if (types.has('REAL')) {\n      return 'REAL'\n    }\n    if (types.has('INTEGER')) {\n      return 'INTEGER'\n    }\n    if (types.has('INTEGER PRIMARY KEY AUTOINCREMENT')) {\n      return 'INTEGER PRIMARY KEY AUTOINCREMENT'\n    }\n    if (types.has('BLOB')) {\n      return 'BLOB'\n    }\n  } else if (types.has('EMPTY_TEXT')) {\n    return 'TEXT'\n  }\n  return types.has('DATETIME') ? 'DATETIME' : (types.values().next().value as StaticDataType)\n}\n\nconst dateRegex =\n  /(\\d{4}-[01]\\d-[0-3]\\d\\s[0-2]\\d:[0-5]\\d:[0-5]\\d)|(\\d{4}-[01]\\d-[0-3]\\d\\s[0-2]\\d:[0-5]\\d)|(\\d{4}-[01]\\d-[0-3]\\d\\s[0-2]\\d)/\nconst isoDateRegex =\n  /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\nconst shortDateRegex = /^(\\d{1,4}\\/\\d{1,2}\\/\\d{1,2}|\\d{2,4}-\\d{1,2}-\\d{1,2})$/\n\nexport const dataTypeForColumnForValue = (value: any): StaticDataType | null => {\n  if (value === null) return null\n  if (value === '') return 'EMPTY_TEXT'\n  if (typeof value === 'boolean') return 'INTEGER'\n  if (isIntNumber(value)) {\n    return 'INTEGER'\n  }\n  if (isRealNumber(value)) {\n    return 'REAL'\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim()\n    if (trimmed.match(shortDateRegex) || trimmed.match(dateRegex) || trimmed.match(isoDateRegex)) {\n      return 'DATETIME'\n    }\n  }\n  return 'TEXT'\n}\n\nfunction isIntNumber(value: any): boolean {\n  if (typeof value !== 'string' && typeof value !== 'number') {\n    return false\n  }\n\n  let stringValue = typeof value === 'string' ? value.replace(/,/g, '').trim() : value.toString()\n\n  let parsedNumber = parseInt(stringValue)\n\n  if (!isNaN(parsedNumber) && isFinite(parsedNumber)) {\n    if (typeof value === 'string') {\n      const validNumberRegex = /^-?\\d+$/\n      return validNumberRegex.test(stringValue)\n    }\n    return value % 1 === 0\n  }\n\n  return false\n}\n\nfunction isRealNumber(value: any): boolean {\n  if (typeof value !== 'string' && typeof value !== 'number') {\n    return false\n  }\n\n  let stringValue = typeof value === 'string' ? value.replace(/,/g, '').trim() : value.toString()\n\n  let parsedNumber = parseFloat(stringValue)\n\n  if (!isNaN(parsedNumber) && isFinite(parsedNumber)) {\n    if (typeof value === 'string') {\n      const validNumberRegex = /^-?\\d+(\\.\\d+)?$/\n      return validNumberRegex.test(stringValue)\n    }\n    return true\n  }\n\n  return false\n}\n\nexport const transformValueForDataType = (value: any, type: StaticDataType): any => {\n  if (value === null) return null\n  if (type === 'DATETIME') {\n    if (value === '') {\n      return null\n    }\n    let val = dayjs(value)\n    if (!val.isValid()) {\n      val = dayjs(value, 'M/D/YY')\n      if (!val.isValid()) {\n        throw new Error(`Invalid date ${value}`)\n      }\n    }\n    return val.toISOString()\n  }\n  if (type === 'REAL' || type === 'INTEGER' || type === 'INTEGER PRIMARY KEY AUTOINCREMENT') {\n    if (typeof value === 'string') {\n      return normalizeNumberString(value)\n    }\n    return parseFloat(value)\n  }\n  return value\n}\n\nfunction normalizeNumberString(input: string): number {\n  // Remove all spaces first\n  let noSpaces = input.replace(/\\s+/g, '')\n\n  // Find the last occurrence of a comma or period to determine the decimal point\n  let lastCommaIndex = noSpaces.lastIndexOf(',')\n  let lastPeriodIndex = noSpaces.lastIndexOf('.')\n\n  // Determine the decimal separator based on the last position of ',' and '.'\n  // If ',' occurs after '.', or '.' doesn't exist, treat ',' as decimal separator\n  if (lastCommaIndex > lastPeriodIndex) {\n    // Replace the last comma with a period, remove all other commas\n    noSpaces =\n      noSpaces.substring(0, lastCommaIndex) +\n      '.' +\n      noSpaces.substring(lastCommaIndex + 1).replace(/,/g, '')\n  } else {\n    // Remove all commas (treating them as thousand separators)\n    noSpaces = noSpaces.replace(/,/g, '')\n  }\n\n  return parseFloat(noSpaces)\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/data-sources/DataSource.ts",
      "content": "import { ISequelizable, ISerializable } from '@jakub.knejzlik/ts-query'\n\nexport interface DataSource {\n  getContentHash: () => string\n  execute: (query: ISequelizable & ISerializable) => Promise<any>\n  executeQueries: (queries: Array<ISequelizable & ISerializable>) => Promise<any>\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/data-sources/index.ts",
      "content": "export { StaticDataSource } from '@/lib/data-sources/StaticDataSource'\nexport { DataSource } from '@/lib/data-sources/DataSource'\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/data-sources/static-database.ts",
      "content": "import initSqlJs, { Database, QueryExecResult } from 'sql.js'\nimport { ISequelizable, SQLiteFlavor } from '@jakub.knejzlik/ts-query'\nimport {\n  StaticDatabaseMetadata,\n  StaticDatabaseMetadataTable,\n  createDatabaseMetadata,\n  transformValueForDataType,\n} from '@/lib/data-sources/database-metadata'\n\nexport type StaticDataType =\n  | 'TEXT'\n  | 'REAL'\n  | 'INTEGER PRIMARY KEY AUTOINCREMENT'\n  | 'INTEGER'\n  | 'BLOB'\n  | 'DATETIME'\n\nexport type StaticDataTable = Record<string, any>[]\nexport type StaticDataTables = { [key: string]: StaticDataTable }\n\nexport type StaticDatabase = {\n  tables: StaticDataTables\n  database: Database\n  metadata: StaticDatabaseMetadata\n}\n\nconst sqlite = new SQLiteFlavor()\n\nconst mapData = (data: QueryExecResult[]): Record<string, any>[] =>\n  data[0].values.map((row) =>\n    row.reduce(\n      (result, value, i) => ({\n        ...result,\n        [data[0].columns[i]]: value,\n      }),\n      {}\n    )\n  )\n\nexport type createDatabaseDatabaseOpts = {\n  enforcePrimaryID?: boolean\n  overrideColumnMapping?: Partial<Record<StaticDataType, StaticDataType>>\n}\n\nexport const createStaticDatabase = async (\n  tables: StaticDataTables,\n  { enforcePrimaryID, overrideColumnMapping }: createDatabaseDatabaseOpts = {}\n): Promise<StaticDatabase> => {\n  const metadata = createDatabaseMetadata({\n    tables,\n    enforcePrimaryID,\n    overrideColumnMapping,\n  })\n  const sqlJs = await initSqlJs({\n    locateFile: (file) => `https://sql.js.org/dist/${file}`,\n    // locateFile: (file) => {\n    //   // return `https://sql.js.org/dist/1.9.0/${file}`;\n    //   return `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/${file}`;\n    // },\n  })\n  const db = new sqlJs.Database()\n\n  for (const tableName of Object.keys(tables)) {\n    if (tables[tableName].length === 0) continue\n    await createStaticDatabaseTable(db, tableName, tables[tableName], metadata.tables[tableName])\n  }\n  return {\n    database: db,\n    tables,\n    metadata,\n  }\n}\n\nexport const importStaticDatabaseTable = async (\n  database: StaticDatabase,\n  table: string,\n  tableData: StaticDataTable,\n  enforcePrimaryID?: boolean,\n  tableMetadata?: StaticDatabaseMetadataTable\n) => {\n  const _tableMetadata =\n    tableMetadata ??\n    createDatabaseMetadata({\n      tables: { table: tableData },\n      enforcePrimaryID,\n    }).tables.table\n  await createStaticDatabaseTable(database.database, table, tableData, _tableMetadata)\n  database.metadata.tables[table] = _tableMetadata\n}\n\nconst createStaticDatabaseTable = async (\n  db: Database,\n  table: string,\n  tableData: StaticDataTable,\n  tableMetadata: StaticDatabaseMetadataTable\n) => {\n  const columns = tableMetadata.columns.map((c) => `\\`${c.name}\\` ${c.type}`)\n\n  await db.run(`CREATE TABLE \\`${table}\\` (${columns.join(', ')})`)\n\n  const CHUNK_SIZE = 300\n  const columnSize = Object.keys(tableData[0]).length\n  for (let i = 0; i < tableData.length; i += CHUNK_SIZE) {\n    const rows = tableData.slice(i, i + CHUNK_SIZE)\n    const values: any[] = []\n    for (const row of rows) {\n      const vals = Object.values(row)\n      if (vals.length > columnSize) {\n        throw new Error(\n          `Row has more columns than expected: ${JSON.stringify(row)} (expected: ${columnSize})`\n        )\n      }\n      values.push(...vals)\n    }\n    try {\n      const vals = values.map((value, index) => {\n        const type = tableMetadata.columns[index % columnSize].type\n        return transformValueForDataType(value, type)\n      })\n      await db.run(\n        `INSERT INTO \\`${table}\\` VALUES ${rows\n          .map((row) => `(${Object.values(row).map(() => '?')})`)\n          .join(',')}`,\n        vals\n      )\n    } catch (err) {\n      throw new Error(\n        `Error inserting row into table with columns [${columns.join(\n          ','\n        )}], error: ${(err as Error).message}`\n      )\n    }\n  }\n}\n\nexport const executeQueries = (db: Database, queries: ISequelizable[]) => {\n  const sqls = queries.map((q) => q.toSQL(sqlite))\n  const results = sqls.map((sql) => {\n    const rows = db!.exec(sql)\n    return rows.length ? mapData(rows) : []\n  })\n\n  return {\n    data: {\n      results,\n    },\n    error: undefined,\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/data-sources/StaticDataSource.ts",
      "content": "import { ISequelizable, ISerializable } from '@jakub.knejzlik/ts-query'\nimport { StaticDatabase } from './database-metadata'\nimport { DataSource } from './DataSource'\nimport {\n  createDatabaseDatabaseOpts,\n  createStaticDatabase,\n  executeQueries,\n  StaticDataTables,\n} from './static-database'\n\nexport class StaticDataSource implements DataSource {\n  private db: Promise<StaticDatabase>\n  private contentHash: string\n\n  constructor(tables: StaticDataTables, opts?: createDatabaseDatabaseOpts) {\n    this.db = createStaticDatabase(tables, opts)\n    this.contentHash = new Date().toISOString()\n  }\n  getContentHash(): string {\n    return this.contentHash\n  }\n  async executeQueries(queries: Array<ISequelizable & ISerializable>): Promise<any> {\n    const db = await this.db\n    const { data } = executeQueries(db.database, queries)\n    return data.results\n  }\n  async execute(query: ISequelizable & ISerializable): Promise<any> {\n    const data = await this.executeQueries([query])\n    return data[0]\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/components/feedback/Spin.tsx",
      "content": "import * as React from 'react'\nimport { cn } from '@/lib/utils'\n\nexport interface SpinProps extends React.HTMLAttributes<HTMLDivElement> {\n  children: React.ReactNode\n  spinning?: boolean\n  overlayClassName?: string\n  spinnerClassName?: string\n  spinnerSize?: number\n  noBlur?: boolean\n  ref?: React.Ref<HTMLDivElement>\n}\n\nexport function Spin({\n  children,\n  spinning = false,\n  className,\n  overlayClassName,\n  spinnerClassName,\n  spinnerSize = 24,\n  noBlur = false,\n  ref,\n  ...props\n}: SpinProps) {\n  return (\n    <div ref={ref} className={cn('relative', className)} {...props}>\n      {children}\n      {spinning && (\n        <div\n          className={cn(\n            'absolute inset-0 flex items-center justify-center bg-background/50',\n            !noBlur && 'backdrop-blur-sm',\n            overlayClassName\n          )}\n        >\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width={spinnerSize}\n            height={spinnerSize}\n            viewBox=\"0 0 24 24\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            className={cn('animate-spin text-primary', spinnerClassName)}\n          >\n            <path d=\"M21 12a9 9 0 1 1-6.219-8.56\" />\n          </svg>\n        </div>\n      )}\n    </div>\n  )\n}\n\nSpin.displayName = 'Spin'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/form/DateRangePicker.tsx",
      "content": "import * as React from 'react'\nimport { CalendarIcon } from 'lucide-react'\nimport { format } from 'date-fns'\nimport { DateRange } from 'react-day-picker'\nimport { Button } from '@/components/ui/button'\nimport { Calendar } from '@/components/ui/calendar'\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'\nimport { cn } from '@/lib/utils'\n\nexport interface DateRangePickerProps {\n  value?: DateRange\n  onChange?: (value: DateRange | undefined) => void\n  placeholder?: string\n  className?: string\n  disabled?: boolean\n  minDate?: Date\n  maxDate?: Date\n  numberOfMonths?: number\n  disabledDates?: (date: Date) => boolean\n}\n\nfunction useMediaQuery(query: string) {\n  const [matches, setMatches] = React.useState(false)\n\n  React.useEffect(() => {\n    const media = window.matchMedia(query)\n    setMatches(media.matches)\n    \n    const listener = (e: MediaQueryListEvent) => setMatches(e.matches)\n    media.addEventListener('change', listener)\n    return () => media.removeEventListener('change', listener)\n  }, [query])\n\n  return matches\n}\n\nexport const DateRangePicker = React.forwardRef<\n  HTMLButtonElement,\n  DateRangePickerProps\n>(({\n  value,\n  onChange,\n  placeholder = 'Pick a date range',\n  className,\n  disabled,\n  minDate,\n  maxDate,\n  numberOfMonths = 2,\n  disabledDates\n}, ref) => {\n  const [open, setOpen] = React.useState(false)\n  const [localRange, setLocalRange] = React.useState<DateRange | undefined>(value)\n  const [isSelectingNewRange, setIsSelectingNewRange] = React.useState(false)\n  const isDesktop = useMediaQuery('(min-width: 768px)')\n\n  React.useEffect(() => {\n    setLocalRange(value)\n  }, [value])\n\n  React.useEffect(() => {\n    if (!open) {\n      setIsSelectingNewRange(false)\n    }\n  }, [open])\n\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (!open) return\n      \n      if (e.key === 'Escape') {\n        e.preventDefault()\n        setOpen(false)\n        setLocalRange(value)\n      }\n    }\n\n    document.addEventListener('keydown', handleKeyDown)\n    return () => document.removeEventListener('keydown', handleKeyDown)\n  }, [open, value])\n\n  const handleSelect = (range: DateRange | undefined) => {\n    if (!range?.from) {\n      setLocalRange(undefined)\n      onChange?.(undefined)\n      setIsSelectingNewRange(false)\n      return\n    }\n    \n    if (range.from && !range.to) {\n      setLocalRange(range)\n      setIsSelectingNewRange(true)\n      return\n    }\n    \n    if (range.from && range.to) {\n      if (isSelectingNewRange) {\n        setLocalRange(range)\n        onChange?.(range)\n        setOpen(false)\n        setIsSelectingNewRange(false)\n      } else {\n        setLocalRange({ from: range.from, to: undefined })\n        setIsSelectingNewRange(true)\n      }\n    }\n  }\n\n  const isDateDisabled = (date: Date) => {\n    if (disabledDates) {\n      return disabledDates(date)\n    }\n    \n    if (minDate && date < minDate) return true\n    if (maxDate && date > maxDate) return true\n    \n    return false\n  }\n\n  const getAriaLabel = () => {\n    if (localRange?.from && localRange?.to) {\n      return `Date range: ${format(localRange.from, 'MMMM d, yyyy')} to ${format(localRange.to, 'MMMM d, yyyy')}`\n    }\n    if (localRange?.from) {\n      return `Date range starting ${format(localRange.from, 'MMMM d, yyyy')}`\n    }\n    return 'Select date range'\n  }\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          ref={ref}\n          variant=\"outline\"\n          disabled={disabled}\n          className={cn(\n            'justify-start text-left font-normal',\n            !localRange && 'text-muted-foreground',\n            className\n          )}\n          aria-label={getAriaLabel()}\n          aria-expanded={open}\n          aria-haspopup=\"dialog\"\n        >\n          <CalendarIcon className=\"mr-2 h-4 w-4\" />\n          {localRange?.from ? (\n            localRange.to ? (\n              <>\n                {format(localRange.from, 'MMM d, yyyy')} - {format(localRange.to, 'MMM d, yyyy')}\n              </>\n            ) : (\n              format(localRange.from, 'MMM d, yyyy')\n            )\n          ) : (\n            placeholder\n          )}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-auto p-0\" align=\"start\">\n        <Calendar\n          mode=\"range\"\n          defaultMonth={localRange?.from || minDate}\n          selected={localRange}\n          onSelect={handleSelect}\n          numberOfMonths={isDesktop ? numberOfMonths : 1}\n          disabled={isDateDisabled}\n        />\n      </PopoverContent>\n    </Popover>\n  )\n})\n\nDateRangePicker.displayName = 'DateRangePicker'",
      "type": "registry:component"
    },
    {
      "path": "registry/lib/date-range-utils.ts",
      "content": "import { DateRange } from 'react-day-picker'\nimport { FilterValue } from '@/components/data-table/DataTableColumn'\nimport dayjs from 'dayjs'\n\nexport const parseFilterValue = (filterValue?: FilterValue): DateRange | undefined => {\n  if (!filterValue?.from && !filterValue?.to) return undefined\n  return {\n    from: filterValue.from ? new Date(filterValue.from) : undefined,\n    to: filterValue.to ? new Date(filterValue.to) : undefined\n  }\n}\n\nexport const toFilterValue = (dateRange?: DateRange): FilterValue | null => {\n  if (!dateRange?.from && !dateRange?.to) return null\n  return {\n    type: 'range',\n    from: dateRange?.from?.toISOString(),\n    to: dateRange?.to?.toISOString()\n  }\n}\n\nexport const formatDateRange = (range?: DateRange): string => {\n  if (!range?.from) return ''\n  if (!range.to) return dayjs(range.from).format('MMM D, YYYY')\n  return `${dayjs(range.from).format('MMM D, YYYY')} - ${dayjs(range.to).format('MMM D, YYYY')}`\n}\n\nexport const DATE_PRESETS = {\n  today: () => ({\n    from: dayjs().startOf('day').toDate(),\n    to: dayjs().endOf('day').toDate()\n  }),\n  yesterday: () => ({\n    from: dayjs().subtract(1, 'day').startOf('day').toDate(),\n    to: dayjs().subtract(1, 'day').endOf('day').toDate()\n  }),\n  last7Days: () => ({\n    from: dayjs().subtract(6, 'days').startOf('day').toDate(),\n    to: dayjs().endOf('day').toDate()\n  }),\n  last30Days: () => ({\n    from: dayjs().subtract(29, 'days').startOf('day').toDate(),\n    to: dayjs().endOf('day').toDate()\n  }),\n  thisMonth: () => ({\n    from: dayjs().startOf('month').toDate(),\n    to: dayjs().endOf('day').toDate()\n  }),\n  lastMonth: () => ({\n    from: dayjs().subtract(1, 'month').startOf('month').toDate(),\n    to: dayjs().subtract(1, 'month').endOf('month').toDate()\n  })\n} as const\n\nexport const validateDateRange = (range?: DateRange): boolean => {\n  if (!range?.from || !range?.to) return true\n  return range.from <= range.to\n}",
      "type": "registry:lib"
    }
  ]
}