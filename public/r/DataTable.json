{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "DataTable",
  "type": "registry:block",
  "title": "DataTable",
  "description": "Data table based on TanStack Table.",
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/react-query",
    "@jakub.knejzlik/ts-query",
    "numeral",
    "sql.js"
  ],
  "devDependencies": [
    "@types/numeral",
    "@types/sql.js"
  ],
  "registryDependencies": [
    "button",
    "dropdown-menu",
    "select",
    "pagination",
    "table"
  ],
  "files": [
    {
      "path": "registry/components/data-table/DataTable.tsx",
      "content": "import {\n  ColumnFiltersState,\n  getCoreRowModel,\n  PaginationState,\n  SortingState,\n  useReactTable,\n  VisibilityState,\n} from '@tanstack/react-table'\nimport * as React from 'react'\n\nimport { DataTableActiveFilters } from '@/components/data-table/DataTableActiveFilters'\nimport {\n  DataTableColumn,\n  FilterMetadata,\n  FilterValue,\n  getDefaultFilterType,\n  mapColumn,\n} from '@/components/data-table/DataTableColumn'\nimport { DataTableContent } from '@/components/data-table/DataTableContent'\nimport {\n  DataTableFilterContext,\n  DataTableFilterProvider,\n} from '@/components/data-table/DataTableFilterContext'\nimport { DataTableFilterDropdown } from '@/components/data-table/DataTableFilterDropdown'\nimport { DataTableFooter } from '@/components/data-table/DataTableFooter'\nimport { DataTableProvider } from '@/components/data-table/DataTableProvider'\nimport { FilterMetadataService } from '@/components/data-table/services/FilterMetadataService'\nimport { Spin } from '@/components/feedback/Spin'\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { Cond, Condition, Fn, Q, SelectQuery } from '@jakub.knejzlik/ts-query'\nimport { useQuery } from '@tanstack/react-query'\n\nexport interface DataTableProps<RecordType> {\n  columns: DataTableColumn<RecordType, any>[]\n  datasource: StaticDataSource\n  query: SelectQuery\n  enableFilters?: boolean\n}\n\n// Helper function to build filter condition from column filter\nconst buildFilterCondition = (\n  column: DataTableColumn<any, any>,\n  filter: any,\n  getFilterValue?: (columnId: string) => FilterValue | undefined\n): Condition | null => {\n  // Get column id - handle both typed columns and regular ColumnDef\n  const columnId =\n    ('id' in column && column.id) || ('accessorKey' in column && String(column.accessorKey)) || null\n  if (!columnId || !filter) {\n    console.log('buildFilterCondition: No column ID or filter', { columnId, filter })\n    return null\n  }\n\n  // Extract FilterValue from TanStack Table format or global storage\n  let filterValue: FilterValue\n\n  if (typeof filter === 'object' && '_filterValue' in filter) {\n    // Extract our actual FilterValue from the TanStack Table wrapper\n    filterValue = filter._filterValue as FilterValue\n  } else if (typeof filter === 'object' && 'type' in filter) {\n    // Direct FilterValue object\n    filterValue = filter as FilterValue\n  } else if (typeof filter === 'string' && getFilterValue) {\n    // Look up in context storage by column ID\n    const storedFilter = getFilterValue(columnId)\n    if (storedFilter) {\n      filterValue = storedFilter\n    } else {\n      // Fallback: treat as simple value\n      filterValue = { type: 'equals', value: filter }\n    }\n  } else if (typeof filter === 'string') {\n    // Fallback: treat as simple value when no getFilterValue provided\n    filterValue = { type: 'equals', value: filter }\n  } else {\n    // Fallback: treat as simple value\n    filterValue = { type: 'equals', value: filter }\n  }\n  const filterType = ('filterType' in column && column.filterType) || getDefaultFilterType(column)\n\n  console.log('buildFilterCondition:', { columnId, filterType, filterValue })\n\n  switch (filterType) {\n    case 'range':\n      if (filterValue.from !== undefined || filterValue.to !== undefined) {\n        // Convert dates to strings if needed for SQL compatibility\n        const convertValue = (val: any) => {\n          if (val instanceof Date) {\n            return val.toISOString()\n          }\n          if (typeof val === 'string' && val.includes('T') && val.includes('Z')) {\n            // Already ISO string\n            return val\n          }\n          return val\n        }\n\n        const from = filterValue.from ? convertValue(filterValue.from) : null\n        const to = filterValue.to ? convertValue(filterValue.to) : null\n\n        if (from !== null && to !== null) {\n          const condition = Cond.between(columnId, [from, to])\n          console.log('Range filter between:', condition)\n          return condition\n        } else if (from !== null) {\n          const condition = Cond.greaterThanOrEqual(columnId, from)\n          console.log('Range filter >=:', condition)\n          return condition\n        } else if (to !== null) {\n          const condition = Cond.lessThanOrEqual(columnId, to)\n          console.log('Range filter <=:', condition)\n          return condition\n        }\n      }\n      console.log('Range filter: No valid range values')\n      return null\n\n    case 'equals':\n      return filterValue.value !== undefined ? Cond.equal(columnId, filterValue.value) : null\n\n    case 'contains':\n      return filterValue.value ? Cond.like(columnId, `%${filterValue.value}%`) : null\n\n    case 'select':\n      return filterValue.value !== undefined && filterValue.value !== null\n        ? Cond.equal(columnId, filterValue.value)\n        : null\n\n    case 'multi-select':\n      return filterValue.values?.length ? Cond.in(columnId, filterValue.values) : null\n\n    case 'comparison':\n      if (filterValue.value !== undefined && filterValue.operator) {\n        switch (filterValue.operator) {\n          case '>':\n            return Cond.greaterThan(columnId, filterValue.value)\n          case '<':\n            return Cond.lessThan(columnId, filterValue.value)\n          case '>=':\n            return Cond.greaterThanOrEqual(columnId, filterValue.value)\n          case '<=':\n            return Cond.lessThanOrEqual(columnId, filterValue.value)\n          case '!=':\n            return Cond.notEqual(columnId, filterValue.value)\n          default:\n            return Cond.equal(columnId, filterValue.value)\n        }\n      }\n      return null\n\n    case 'toggle':\n      return filterValue.value !== undefined && filterValue.value !== null\n        ? Cond.equal(columnId, filterValue.value)\n        : null\n\n    default:\n      // Fallback for simple value filters\n      if (typeof filter === 'string' || typeof filter === 'number' || typeof filter === 'boolean') {\n        return Cond.equal(columnId, filter)\n      }\n      return null\n  }\n}\n\n// Internal component that uses the filter context\nconst DataTableInner = <RecordType,>({\n  columns,\n  datasource,\n  query,\n  enableFilters = false,\n  children,\n}: React.PropsWithChildren<DataTableProps<RecordType>>) => {\n  const [sorting, setSorting] = React.useState<SortingState>([])\n  const [pagination, setPagination] = React.useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: 10,\n  })\n  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([])\n  const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>({})\n  const [rowSelection, setRowSelection] = React.useState({})\n  const [filterMetadata, setFilterMetadata] = React.useState<Record<string, FilterMetadata>>({})\n  const { getFilterValue } = React.useContext(DataTableFilterContext) || {\n    getFilterValue: () => undefined,\n  }\n\n  // Prefetch metadata for filterable columns\n  React.useEffect(() => {\n    if (!enableFilters) return\n\n    FilterMetadataService.fetchAllMetadata(datasource, query, columns)\n      .then(setFilterMetadata)\n      .catch((error) => {\n        console.warn('Failed to fetch filter metadata:', error)\n      })\n  }, [enableFilters, datasource, query, columns])\n\n  let sourceQuery = query\n\n  // Apply column filters to the query\n  if (columnFilters.length > 0) {\n    const conditions: (Condition | null)[] = columnFilters\n      .map((filter) => {\n        const column = columns.find(\n          (c) =>\n            ('id' in c && c.id === filter.id) ||\n            ('accessorKey' in c && String(c.accessorKey) === filter.id)\n        )\n        if (!column) return null\n        return buildFilterCondition(column, filter.value, getFilterValue)\n      })\n      .filter(Boolean)\n\n    if (conditions.length > 0) {\n      sourceQuery = sourceQuery.where(Cond.and(conditions as Condition[]))\n    }\n  }\n\n  const countQuery = Q.select().addField(Fn.count('*'), 'count').from(sourceQuery)\n\n  if (sorting.length > 0) {\n    for (const sorter of sorting) {\n      sourceQuery = sourceQuery.orderBy(sorter.id, sorter.desc ? 'DESC' : 'ASC')\n    }\n  }\n  sourceQuery = sourceQuery.offset(pagination.pageIndex * pagination.pageSize)\n  sourceQuery = sourceQuery.limit(pagination.pageSize)\n\n  const { data, isLoading } = useQuery({\n    queryKey: ['data-table', datasource.getContentHash(), sourceQuery.toSQL()],\n    queryFn: async () => {\n      // Debug: Log the SQL queries\n      console.log('Data query SQL:', sourceQuery.toSQL())\n      console.log('Count query SQL:', countQuery.toSQL())\n      console.log('Active filters:', columnFilters)\n\n      const [rows, count] = await datasource.executeQueries([sourceQuery, countQuery])\n      return [rows, { count: count[0].count }] as [RecordType[], { count: number }]\n    },\n  })\n\n  const [_data, count] = data ?? [null, null]\n\n  const table = useReactTable({\n    data: _data ?? [],\n    columns: columns.map((col) =>\n      mapColumn(col, {\n        datasource,\n        query,\n        enableFilters,\n        metadata: filterMetadata,\n        FilterDropdown: DataTableFilterDropdown,\n      })\n    ),\n    manualSorting: true,\n    manualFiltering: true,\n    manualPagination: true,\n    rowCount: count ? count.count : 0,\n    // autoResetPageIndex: true,\n    onSortingChange: setSorting,\n    onColumnFiltersChange: setColumnFilters,\n    onPaginationChange: setPagination,\n    getCoreRowModel: getCoreRowModel(),\n    onColumnVisibilityChange: setColumnVisibility,\n    onRowSelectionChange: setRowSelection,\n    enableRowPinning: true,\n    state: {\n      sorting,\n      columnFilters,\n      columnVisibility,\n      rowSelection,\n      pagination,\n      rowPinning: { bottom: [''], top: [''] },\n      columnPinning: {\n        // left: ['status'],\n        right: ['actions'],\n      },\n    },\n  })\n\n  return (\n    <DataTableProvider table={table}>\n      <div className=\"w-full\">\n        {children ?? (\n          <>\n            {/* <div className=\"flex items-center py-4\">\n              <DataTableToolbar />\n            </div> */}\n            {enableFilters && columnFilters.length > 0 && (\n              <DataTableActiveFilters columns={columns} />\n            )}\n            <div className=\"rounded-sm border\">\n              <Spin spinning={isLoading}>\n                <DataTableContent />\n              </Spin>\n            </div>\n            <div className=\"flex items-center justify-end space-x-2 py-4\">\n              <DataTableFooter />\n            </div>\n          </>\n        )}\n      </div>\n    </DataTableProvider>\n  )\n}\n\n// Export wrapper component that provides the filter context\nexport const DataTable = <RecordType,>(\n  props: React.PropsWithChildren<DataTableProps<RecordType>>\n) => {\n  return (\n    <DataTableFilterProvider>\n      <DataTableInner {...props} />\n    </DataTableFilterProvider>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableColumn.tsx",
      "content": "import { ColumnDef } from '@tanstack/react-table'\nimport { ChevronDownIcon, ChevronsUpDownIcon, ChevronUpIcon } from 'lucide-react'\n\nimport { Button } from '@/components/ui/button'\nimport numeral from 'numeral'\nimport dayjs from 'dayjs'\nimport * as React from 'react'\n\n// Filter type definitions\nexport type FilterType =\n  | 'range' // Works for number AND date\n  | 'equals' // Works for all types\n  | 'contains' // String-specific\n  | 'select' // Dropdown selection (any type)\n  | 'multi-select' // Multiple selection (any type)\n  | 'comparison' // Single value with operator (>, <, etc.)\n  | 'toggle' // Boolean-specific\n  | 'custom' // Custom component\n  | 'none' // No filtering\n\nexport type ComparisonOperator = '=' | '!=' | '>' | '<' | '>=' | '<='\n\nexport interface FilterValue {\n  type: FilterType\n  value?: any\n  from?: any\n  to?: any\n  values?: any[]\n  operator?: ComparisonOperator\n}\n\nexport interface FilterMetadata {\n  // For numeric/date columns\n  min?: number | Date\n  max?: number | Date\n\n  // For string columns\n  distinctValues?: Array<{ value: any; count: number }>\n  totalDistinct?: number\n\n  // For all columns\n  nullCount?: number\n  totalCount?: number\n}\n\nexport interface FilterOptions {\n  // For select/multi-select\n  options?: Array<{ label: string; value: any }>\n\n  // For number ranges\n  min?: number\n  max?: number\n  step?: number\n\n  // For date ranges\n  minDate?: Date\n  maxDate?: Date\n\n  // For text filters\n  caseSensitive?: boolean\n\n  // Custom filter render\n  renderFilter?: (props: any) => React.ReactNode\n\n  // Presets for quick filtering\n  presets?: Array<{\n    label: string\n    value: any\n  }>\n}\n\n// Base column type with filter properties - using intersection type instead of extends\ntype DataTableColumnBase<Data, Value = unknown> = ColumnDef<Data, Value> & {\n  id?: string\n  title?: React.ReactNode\n  filterable?: boolean\n  filterType?: FilterType\n  filterOptions?: FilterOptions\n}\n\nexport type DataTableColumnString<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'string'\n}\nexport type DataTableColumnNumber<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'number'\n  format?: string // e.g. '0,0.00' for 1,000.00\n}\nexport type DataTableColumnDate<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'date'\n}\nexport type DataTableColumnBoolean<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'boolean'\n}\nexport type DataTableColumnActions<Data, Value = unknown> = DataTableColumnBase<Data, Value> & {\n  type: 'actions'\n}\n\nexport type DataTableColumn<Data, Value = unknown> =\n  | DataTableColumnString<Data, Value>\n  | DataTableColumnNumber<Data, Value>\n  | DataTableColumnDate<Data, Value>\n  | DataTableColumnBoolean<Data, Value>\n  | DataTableColumnActions<Data, Value>\n  | ColumnDef<Data, Value>\n\n// Helper function to get default filter type based on column type\nexport const getDefaultFilterType = (column: DataTableColumn<any, any>): FilterType => {\n  if (!('type' in column)) return 'equals'\n\n  switch (column.type) {\n    case 'string':\n      return 'contains'\n    case 'number':\n    case 'date':\n      return 'range'\n    case 'boolean':\n      return 'toggle'\n    case 'actions':\n      return 'none'\n    default:\n      return 'equals'\n  }\n}\n\n// Context for passing additional data to mapColumn\nexport interface MapColumnContext {\n  datasource?: any\n  query?: any\n  metadata?: FilterMetadata\n  enableFilters?: boolean\n  FilterDropdown?: React.ComponentType<any>\n}\n\nexport const mapColumn = <Data, Value>(\n  column: DataTableColumn<Data, Value>,\n  context?: MapColumnContext\n): ColumnDef<Data, Value> => {\n  const res: ColumnDef<Data, Value> = {\n    header: ({ column: tableColumn }) => {\n      const FilterDropdown = context?.FilterDropdown\n\n      return (\n        <div className=\"flex items-center justify-center gap-0.5\">\n          <Button\n            variant=\"ghost\"\n            onClick={({ shiftKey }) => {\n              tableColumn.getIsSorted() === 'desc'\n                ? tableColumn.clearSorting()\n                : tableColumn.toggleSorting(tableColumn.getIsSorted() === 'asc', shiftKey)\n            }}\n            className=\"h-auto py-1 pr-1\"\n          >\n            <span className=\"flex items-center gap-1\">\n              {('title' in column && column.title) ||\n                ('id' in column && column.id) ||\n                ('accessorKey' in column && String(column.accessorKey)) ||\n                'Column'}\n              {!tableColumn.getIsSorted() && <ChevronsUpDownIcon className=\"h-4 w-4\" />}\n              {tableColumn.getIsSorted() === 'asc' && <ChevronUpIcon className=\"h-4 w-4\" />}\n              {tableColumn.getIsSorted() === 'desc' && <ChevronDownIcon className=\"h-4 w-4\" />}\n            </span>\n          </Button>\n          {context?.enableFilters &&\n            FilterDropdown &&\n            ('filterable' in column && column.filterable !== false) &&\n            (!('type' in column) || column.type !== 'actions') && (\n              <FilterDropdown\n                column={column}\n                datasource={context.datasource}\n                query={context.query}\n                metadata={\n                  context.metadata?.[\n                    (('id' in column && column.id) ||\n                      ('accessorKey' in column && String(column.accessorKey)) ||\n                      '') as keyof FilterMetadata\n                  ] as any\n                }\n                value={tableColumn.getFilterValue()}\n                onChange={(value: any) => {\n                  console.log('DataTableColumn: Setting filter value for', tableColumn.id, {\n                    value,\n                    currentValue: tableColumn.getFilterValue(),\n                  })\n\n                  // Use a simple primitive value that TanStack Table will accept\n                  let tanstackValue: any = null\n\n                  if (value && typeof value === 'object' && 'type' in value) {\n                    const filterId = `${tableColumn.id}_${Date.now()}`\n                    // Use a simple string that TanStack Table will accept\n                    tanstackValue = filterId\n                  }\n\n                  tableColumn.setFilterValue(tanstackValue)\n                  console.log(\n                    'DataTableColumn: Filter value set, new value:',\n                    tableColumn.getFilterValue()\n                  )\n                }}\n              />\n            )}\n        </div>\n      )\n    },\n    ...column,\n  }\n  if (!('type' in column)) {\n    return res\n  }\n\n  switch (column.type) {\n    case 'string':\n      return {\n        ...res,\n      }\n    case 'number':\n      return {\n        size: 100,\n        cell: ({ getValue }) => (\n          <div className={`text-right`}>\n            {numeral(getValue()).format(column.format ?? '0,0.00')}\n          </div>\n        ),\n        ...res,\n      }\n    case 'date':\n      return {\n        ...res,\n        cell: ({ getValue }) => {\n          const value = getValue()\n          if (value === null || value === undefined || value === '') {\n            return <div className=\"text-center text-muted-foreground\">-</div>\n          }\n          const date = dayjs(value as any)\n          if (!date.isValid()) {\n            return <div className=\"text-center text-muted-foreground\">-</div>\n          }\n          return <div className=\"text-center\">{date.format('DD.MM.YYYY HH:mm:ss')}</div>\n        },\n      }\n    case 'boolean':\n      return {\n        ...res,\n      }\n    case 'actions':\n      return {\n        // Let the column auto-size based on content\n        // This will adapt to 1 button (~40px) or 2 buttons (~80px)\n        ...res,\n      }\n    default:\n      return res\n  }\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableContent.tsx",
      "content": "import { flexRender } from '@tanstack/react-table'\n\nimport type { Column } from '@tanstack/react-table'\n\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table'\nimport { CSSProperties } from 'react'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\n\nconst getCommonPinningStyles = (column: Column<any>): CSSProperties => {\n  const isPinned = column.getIsPinned()\n  const isLastLeftPinnedColumn = isPinned === 'left' && column.getIsLastColumn('left')\n  const isFirstRightPinnedColumn = isPinned === 'right' && column.getIsFirstColumn('right')\n\n  return {\n    boxShadow: isLastLeftPinnedColumn\n      ? '-2px 0 4px -2px gray inset'\n      : isFirstRightPinnedColumn\n        ? '3px 0 3px -3px gray inset'\n        : undefined,\n    left: isPinned === 'left' ? `${column.getStart('left')}px` : undefined,\n    right: isPinned === 'right' ? `${column.getAfter('right')}px` : undefined,\n    // opacity: isPinned ? 1 : 1,\n    position: isPinned ? 'sticky' : 'relative',\n    width: column.getSize(),\n    zIndex: isPinned ? 1 : 0,\n  }\n}\n\nexport const DataTableContent = <RecordType,>() => {\n  const table = useDataTable<RecordType>()\n  return (\n    <Table>\n      <TableHeader>\n        {table.getHeaderGroups().map((headerGroup) => (\n          <TableRow key={headerGroup.id}>\n            {headerGroup.headers.map((header) => {\n              const { column } = header\n              return (\n                <TableHead key={header.id} style={{ ...getCommonPinningStyles(column) }}>\n                  {header.isPlaceholder\n                    ? null\n                    : flexRender(header.column.columnDef.header, header.getContext())}\n                </TableHead>\n              )\n            })}\n          </TableRow>\n        ))}\n      </TableHeader>\n      <TableBody>\n        {table.getRowModel().rows?.length ? (\n          table.getRowModel().rows.map((row) => (\n            <TableRow key={row.id} data-state={row.getIsSelected() && 'selected'}>\n              {row.getVisibleCells().map((cell) => (\n                <TableCell\n                  key={cell.id}\n                  style={{ ...getCommonPinningStyles(cell.column), width: 0 }}\n                >\n                  {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                </TableCell>\n              ))}\n            </TableRow>\n          ))\n        ) : (\n          <TableRow>\n            <TableCell colSpan={table.getAllColumns().length} className=\"h-24 text-center\">\n              No results.\n            </TableCell>\n          </TableRow>\n        )}\n      </TableBody>\n    </Table>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableFooter.tsx",
      "content": "'use client'\n\nimport { DataTablePageSwitcher } from '@/components/data-table/DataTablePageSwitcher'\nimport { DataTablePagination } from '@/components/data-table/DataTablePagination'\n\nexport function DataTableFooter() {\n  return (\n    <div className=\"flex items-center justify-between px-2 text-sm\">\n      <DataTablePagination />\n      <div className=\"flex items-center space-x-6 lg:space-x-8\">\n        <div className=\"flex items-center space-x-2\">\n          <DataTablePageSwitcher />\n        </div>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTablePageSwitcher.tsx",
      "content": "'use client'\n\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\n\nexport function DataTablePageSwitcher<TData>() {\n  const table = useDataTable<TData>()\n\n  return (\n    <Select\n      value={`${table.getState().pagination.pageSize}`}\n      onValueChange={(value) => {\n        table.setPageSize(Number(value))\n      }}\n    >\n      <SelectTrigger className=\"h-8 w-[120px]\" size=\"sm\">\n        <SelectValue placeholder={table.getState().pagination.pageSize} />\n      </SelectTrigger>\n      <SelectContent side=\"top\">\n        {[10, 20, 30, 40, 50].map((pageSize) => (\n          <SelectItem key={pageSize} value={`${pageSize}`}>\n            {pageSize} / page\n          </SelectItem>\n        ))}\n      </SelectContent>\n    </Select>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTablePagination.tsx",
      "content": "'use client'\n\nimport {\n  Pagination,\n  PaginationContent,\n  PaginationEllipsis,\n  PaginationItem,\n  PaginationLink,\n  PaginationNext,\n  PaginationPrevious,\n} from '@/components/ui/pagination'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\n\nexport function DataTablePagination<TData>() {\n  const table = useDataTable<TData>()\n  const currentPage = table.getState().pagination.pageIndex + 1\n  const totalPages = table.getPageCount()\n\n  const getVisiblePages = () => {\n    const pages: (number | 'ellipsis')[] = []\n\n    if (totalPages <= 5) {\n      for (let i = 1; i <= totalPages; i++) {\n        pages.push(i)\n      }\n    } else {\n      pages.push(1)\n\n      if (currentPage <= 3) {\n        for (let i = 2; i <= 3; i++) {\n          pages.push(i)\n        }\n        pages.push('ellipsis')\n        pages.push(totalPages)\n      } else if (currentPage >= totalPages - 2) {\n        pages.push('ellipsis')\n        for (let i = totalPages - 2; i <= totalPages; i++) {\n          pages.push(i)\n        }\n      } else {\n        pages.push('ellipsis')\n        for (let i = currentPage - 1; i <= currentPage + 1; i++) {\n          pages.push(i)\n        }\n        pages.push('ellipsis')\n        pages.push(totalPages)\n      }\n    }\n\n    return pages\n  }\n\n  const visiblePages = getVisiblePages()\n\n  return (\n    <Pagination>\n      <PaginationContent>\n        <PaginationItem>\n          <PaginationPrevious\n            href=\"#\"\n            onClick={(e) => {\n              e.preventDefault()\n              table.previousPage()\n            }}\n            className={\n              !table.getCanPreviousPage() ? 'pointer-events-none opacity-50' : 'cursor-pointer'\n            }\n          />\n        </PaginationItem>\n\n        {visiblePages.map((page, index) => {\n          if (page === 'ellipsis') {\n            return (\n              <PaginationItem key={`ellipsis-${index}`}>\n                <PaginationEllipsis />\n              </PaginationItem>\n            )\n          }\n\n          return (\n            <PaginationItem key={page}>\n              <PaginationLink\n                href=\"#\"\n                onClick={(e) => {\n                  e.preventDefault()\n                  table.setPageIndex(page - 1)\n                }}\n                isActive={currentPage === page}\n                className=\"cursor-pointer\"\n              >\n                {page}\n              </PaginationLink>\n            </PaginationItem>\n          )\n        })}\n\n        <PaginationItem>\n          <PaginationNext\n            href=\"#\"\n            onClick={(e) => {\n              e.preventDefault()\n              table.nextPage()\n            }}\n            className={\n              !table.getCanNextPage() ? 'pointer-events-none opacity-50' : 'cursor-pointer'\n            }\n          />\n        </PaginationItem>\n      </PaginationContent>\n    </Pagination>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableProvider.tsx",
      "content": "import { useReactTable } from '@tanstack/react-table'\nimport * as React from 'react'\n\ninterface DataTableContextValue<RecordType> {\n  table: ReturnType<typeof useReactTable<RecordType>>\n}\n\nconst DataTableContext = React.createContext<DataTableContextValue<any> | undefined>(undefined)\n\nexport function DataTableProvider<RecordType>({\n  table,\n  children,\n}: React.PropsWithChildren<{ table: ReturnType<typeof useReactTable<RecordType>> }>) {\n  return <DataTableContext.Provider value={{ table }}>{children}</DataTableContext.Provider>\n}\n\nexport function useDataTable<RecordType>() {\n  const context = React.useContext(DataTableContext)\n  if (!context) {\n    throw new Error('useDataTable must be used within a DataTableProvider')\n  }\n  return context.table as ReturnType<typeof useReactTable<RecordType>>\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/DataTableToolbar.tsx",
      "content": "import { ChevronDown } from 'lucide-react'\n\nimport { Button } from '@/components/ui/button'\nimport {\n  DropdownMenu,\n  DropdownMenuCheckboxItem,\n  DropdownMenuContent,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu'\nimport { useDataTable } from '@/components/data-table/DataTableProvider'\n\nexport const DataTableToolbar = <RecordType,>() => {\n  const table = useDataTable<RecordType>()\n  return (\n    <div className=\"flex items-center py-4\">\n      <DropdownMenu>\n        <DropdownMenuTrigger asChild>\n          <Button variant=\"outline\" className=\"ml-auto\">\n            Columns <ChevronDown />\n          </Button>\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"end\">\n          {table\n            .getAllColumns()\n            .filter((column) => column.getCanHide())\n            .map((column) => {\n              return (\n                <DropdownMenuCheckboxItem\n                  key={column.id}\n                  className=\"capitalize\"\n                  checked={column.getIsVisible()}\n                  onCheckedChange={(value) => column.toggleVisibility(!!value)}\n                >\n                  {column.id}\n                </DropdownMenuCheckboxItem>\n              )\n            })}\n        </DropdownMenuContent>\n      </DropdownMenu>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/components/data-table/StaticDataTable.tsx",
      "content": "import * as React from 'react'\n\nimport { StaticDataSource } from '@/lib/data-sources'\nimport { Q } from '@jakub.knejzlik/ts-query'\nimport { DataTable, DataTableProps } from '@/components/data-table/DataTable'\n\ntype RowType = Record<string, any>\n\ninterface StaticDataTableProps<RecordType extends RowType>\n  extends Omit<DataTableProps<RecordType>, 'datasource' | 'query'> {\n  data: RecordType[]\n}\n\nexport const StaticDataTable = <RecordType extends RowType>({\n  data,\n  ...rest\n}: React.PropsWithChildren<StaticDataTableProps<RecordType>>) => {\n  const datasource = React.useMemo(() => new StaticDataSource({ table: data }), [data])\n\n  return (\n    <DataTable<RecordType> datasource={datasource} query={Q.select().from('table')} {...rest} />\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/lib/data-sources/database-metadata.ts",
      "content": "import { Database } from 'sql.js'\n// import { Resource } from './models/Resource';\nimport dayjs from 'dayjs'\n\nexport type StaticDataType =\n  | 'TEXT'\n  | 'REAL'\n  | 'INTEGER PRIMARY KEY AUTOINCREMENT'\n  | 'INTEGER'\n  | 'BLOB'\n  | 'DATETIME'\n  | 'EMPTY_TEXT'\n\nexport type StaticDataTable = Record<string, any>[]\nexport type StaticDataTables = { [key: string]: StaticDataTable }\n\nexport type StaticDatabaseMetadataTableColumn = {\n  name: string\n  label: string\n  type: StaticDataType\n}\nexport type StaticDatabaseMetadataTable = {\n  columns: StaticDatabaseMetadataTableColumn[]\n}\nexport type StaticDatabaseMetadata = {\n  tables: Record<string, StaticDatabaseMetadataTable>\n}\n\nexport type StaticDatabase = {\n  tables: StaticDataTables\n  database: Database\n  metadata: StaticDatabaseMetadata\n}\n\nexport type createDatabaseMetadataOpts = {\n  tables: StaticDataTables\n  enforcePrimaryID?: boolean\n  overrideColumnMapping?: Partial<Record<StaticDataType, StaticDataType>>\n}\n\nexport const createDatabaseMetadata = ({\n  tables,\n  enforcePrimaryID,\n  overrideColumnMapping,\n}: createDatabaseMetadataOpts): StaticDatabaseMetadata => {\n  return {\n    tables: Object.keys(tables).reduce(\n      (result, tableName) => {\n        result[tableName] = {\n          columns: Object.keys(tables[tableName]?.[0] ?? {}).map((col, i) => {\n            const type = dataTypeForColumn(col, tables[tableName] ?? [], enforcePrimaryID ?? false)\n            return {\n              name:\n                col\n                  .normalize('NFD')\n                  .replace(/[\\u0300-\\u036f]/g, '')\n                  .replace(/\\s|[^\\w]/g, '_') || `column_${i}`,\n              label: col,\n              type: overrideColumnMapping?.[type] || type,\n            }\n          }),\n        }\n        return result\n      },\n      {} as Record<string, StaticDatabaseMetadataTable>\n    ),\n  }\n}\n\nexport const dataTypeForColumn = (\n  columnName: string,\n  tableData: StaticDataTable,\n  enforcePrimaryID: boolean\n): StaticDataType => {\n  if (columnName === 'id' && enforcePrimaryID) return 'INTEGER PRIMARY KEY AUTOINCREMENT'\n  const firstNCount = 500\n  const values = tableData.slice(0, firstNCount).map((item) => item[columnName])\n  const types = new Set<StaticDataType>()\n  for (const value of values) {\n    const type = dataTypeForColumnForValue(value)\n    if (type !== null) {\n      types.add(type)\n    }\n  }\n\n  if (types.size > 1) {\n    if (types.has('EMPTY_TEXT') && types.has('DATETIME')) {\n      return 'DATETIME'\n    }\n    if (types.has('TEXT')) {\n      return 'TEXT'\n    }\n    if (types.has('REAL')) {\n      return 'REAL'\n    }\n    if (types.has('INTEGER')) {\n      return 'INTEGER'\n    }\n    if (types.has('INTEGER PRIMARY KEY AUTOINCREMENT')) {\n      return 'INTEGER PRIMARY KEY AUTOINCREMENT'\n    }\n    if (types.has('BLOB')) {\n      return 'BLOB'\n    }\n  } else if (types.has('EMPTY_TEXT')) {\n    return 'TEXT'\n  }\n  return types.has('DATETIME') ? 'DATETIME' : (types.values().next().value as StaticDataType)\n}\n\nconst dateRegex =\n  /(\\d{4}-[01]\\d-[0-3]\\d\\s[0-2]\\d:[0-5]\\d:[0-5]\\d)|(\\d{4}-[01]\\d-[0-3]\\d\\s[0-2]\\d:[0-5]\\d)|(\\d{4}-[01]\\d-[0-3]\\d\\s[0-2]\\d)/\nconst isoDateRegex =\n  /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\nconst shortDateRegex = /^(\\d{1,4}\\/\\d{1,2}\\/\\d{1,2}|\\d{2,4}-\\d{1,2}-\\d{1,2})$/\n\nexport const dataTypeForColumnForValue = (value: any): StaticDataType | null => {\n  if (value === null) return null\n  if (value === '') return 'EMPTY_TEXT'\n  if (typeof value === 'boolean') return 'INTEGER'\n  if (isIntNumber(value)) {\n    return 'INTEGER'\n  }\n  if (isRealNumber(value)) {\n    return 'REAL'\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim()\n    if (trimmed.match(shortDateRegex) || trimmed.match(dateRegex) || trimmed.match(isoDateRegex)) {\n      return 'DATETIME'\n    }\n  }\n  return 'TEXT'\n}\n\nfunction isIntNumber(value: any): boolean {\n  if (typeof value !== 'string' && typeof value !== 'number') {\n    return false\n  }\n\n  let stringValue = typeof value === 'string' ? value.replace(/,/g, '').trim() : value.toString()\n\n  let parsedNumber = parseInt(stringValue)\n\n  if (!isNaN(parsedNumber) && isFinite(parsedNumber)) {\n    if (typeof value === 'string') {\n      const validNumberRegex = /^-?\\d+$/\n      return validNumberRegex.test(stringValue)\n    }\n    return value % 1 === 0\n  }\n\n  return false\n}\n\nfunction isRealNumber(value: any): boolean {\n  if (typeof value !== 'string' && typeof value !== 'number') {\n    return false\n  }\n\n  let stringValue = typeof value === 'string' ? value.replace(/,/g, '').trim() : value.toString()\n\n  let parsedNumber = parseFloat(stringValue)\n\n  if (!isNaN(parsedNumber) && isFinite(parsedNumber)) {\n    if (typeof value === 'string') {\n      const validNumberRegex = /^-?\\d+(\\.\\d+)?$/\n      return validNumberRegex.test(stringValue)\n    }\n    return true\n  }\n\n  return false\n}\n\nexport const transformValueForDataType = (value: any, type: StaticDataType): any => {\n  if (value === null) return null\n  if (type === 'DATETIME') {\n    if (value === '') {\n      return null\n    }\n    let val = dayjs(value)\n    if (!val.isValid()) {\n      val = dayjs(value, 'M/D/YY')\n      if (!val.isValid()) {\n        throw new Error(`Invalid date ${value}`)\n      }\n    }\n    return val.toISOString()\n  }\n  if (type === 'REAL' || type === 'INTEGER' || type === 'INTEGER PRIMARY KEY AUTOINCREMENT') {\n    if (typeof value === 'string') {\n      return normalizeNumberString(value)\n    }\n    return parseFloat(value)\n  }\n  return value\n}\n\nfunction normalizeNumberString(input: string): number {\n  // Remove all spaces first\n  let noSpaces = input.replace(/\\s+/g, '')\n\n  // Find the last occurrence of a comma or period to determine the decimal point\n  let lastCommaIndex = noSpaces.lastIndexOf(',')\n  let lastPeriodIndex = noSpaces.lastIndexOf('.')\n\n  // Determine the decimal separator based on the last position of ',' and '.'\n  // If ',' occurs after '.', or '.' doesn't exist, treat ',' as decimal separator\n  if (lastCommaIndex > lastPeriodIndex) {\n    // Replace the last comma with a period, remove all other commas\n    noSpaces =\n      noSpaces.substring(0, lastCommaIndex) +\n      '.' +\n      noSpaces.substring(lastCommaIndex + 1).replace(/,/g, '')\n  } else {\n    // Remove all commas (treating them as thousand separators)\n    noSpaces = noSpaces.replace(/,/g, '')\n  }\n\n  return parseFloat(noSpaces)\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/data-sources/DataSource.ts",
      "content": "import { ISequelizable, ISerializable } from '@jakub.knejzlik/ts-query'\n\nexport interface DataSource {\n  getContentHash: () => string\n  execute: (query: ISequelizable & ISerializable) => Promise<any>\n  executeQueries: (queries: Array<ISequelizable & ISerializable>) => Promise<any>\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/data-sources/index.ts",
      "content": "export { StaticDataSource } from '@/lib/data-sources/StaticDataSource'\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/data-sources/static-database.ts",
      "content": "import initSqlJs, { Database, QueryExecResult } from 'sql.js'\nimport { ISequelizable, SQLiteFlavor } from '@jakub.knejzlik/ts-query'\nimport {\n  StaticDatabaseMetadata,\n  StaticDatabaseMetadataTable,\n  createDatabaseMetadata,\n  transformValueForDataType,\n} from '@/lib/data-sources/database-metadata'\n\nexport type StaticDataType =\n  | 'TEXT'\n  | 'REAL'\n  | 'INTEGER PRIMARY KEY AUTOINCREMENT'\n  | 'INTEGER'\n  | 'BLOB'\n  | 'DATETIME'\n\nexport type StaticDataTable = Record<string, any>[]\nexport type StaticDataTables = { [key: string]: StaticDataTable }\n\nexport type StaticDatabase = {\n  tables: StaticDataTables\n  database: Database\n  metadata: StaticDatabaseMetadata\n}\n\nconst sqlite = new SQLiteFlavor()\n\nconst mapData = (data: QueryExecResult[]): Record<string, any>[] =>\n  data[0].values.map((row) =>\n    row.reduce(\n      (result, value, i) => ({\n        ...result,\n        [data[0].columns[i]]: value,\n      }),\n      {}\n    )\n  )\n\nexport type createDatabaseDatabaseOpts = {\n  enforcePrimaryID?: boolean\n  overrideColumnMapping?: Partial<Record<StaticDataType, StaticDataType>>\n}\n\nexport const createStaticDatabase = async (\n  tables: StaticDataTables,\n  { enforcePrimaryID, overrideColumnMapping }: createDatabaseDatabaseOpts = {}\n): Promise<StaticDatabase> => {\n  const metadata = createDatabaseMetadata({\n    tables,\n    enforcePrimaryID,\n    overrideColumnMapping,\n  })\n  const sqlJs = await initSqlJs({\n    locateFile: (file) => `https://sql.js.org/dist/${file}`,\n    // locateFile: (file) => {\n    //   // return `https://sql.js.org/dist/1.9.0/${file}`;\n    //   return `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/${file}`;\n    // },\n  })\n  const db = new sqlJs.Database()\n\n  for (const tableName of Object.keys(tables)) {\n    if (tables[tableName].length === 0) continue\n    await createStaticDatabaseTable(db, tableName, tables[tableName], metadata.tables[tableName])\n  }\n  return {\n    database: db,\n    tables,\n    metadata,\n  }\n}\n\nexport const importStaticDatabaseTable = async (\n  database: StaticDatabase,\n  table: string,\n  tableData: StaticDataTable,\n  enforcePrimaryID?: boolean,\n  tableMetadata?: StaticDatabaseMetadataTable\n) => {\n  const _tableMetadata =\n    tableMetadata ??\n    createDatabaseMetadata({\n      tables: { table: tableData },\n      enforcePrimaryID,\n    }).tables.table\n  await createStaticDatabaseTable(database.database, table, tableData, _tableMetadata)\n  database.metadata.tables[table] = _tableMetadata\n}\n\nconst createStaticDatabaseTable = async (\n  db: Database,\n  table: string,\n  tableData: StaticDataTable,\n  tableMetadata: StaticDatabaseMetadataTable\n) => {\n  const columns = tableMetadata.columns.map((c) => `\\`${c.name}\\` ${c.type}`)\n\n  await db.run(`CREATE TABLE \\`${table}\\` (${columns.join(', ')})`)\n\n  const CHUNK_SIZE = 300\n  const columnSize = Object.keys(tableData[0]).length\n  for (let i = 0; i < tableData.length; i += CHUNK_SIZE) {\n    const rows = tableData.slice(i, i + CHUNK_SIZE)\n    const values: any[] = []\n    for (const row of rows) {\n      const vals = Object.values(row)\n      if (vals.length > columnSize) {\n        throw new Error(\n          `Row has more columns than expected: ${JSON.stringify(row)} (expected: ${columnSize})`\n        )\n      }\n      values.push(...vals)\n    }\n    try {\n      const vals = values.map((value, index) => {\n        const type = tableMetadata.columns[index % columnSize].type\n        return transformValueForDataType(value, type)\n      })\n      await db.run(\n        `INSERT INTO \\`${table}\\` VALUES ${rows\n          .map((row) => `(${Object.values(row).map(() => '?')})`)\n          .join(',')}`,\n        vals\n      )\n    } catch (err) {\n      throw new Error(\n        `Error inserting row into table with columns [${columns.join(\n          ','\n        )}], error: ${(err as Error).message}`\n      )\n    }\n  }\n}\n\nexport const executeQueries = (db: Database, queries: ISequelizable[]) => {\n  const sqls = queries.map((q) => q.toSQL(sqlite))\n  const results = sqls.map((sql) => {\n    const rows = db!.exec(sql)\n    return rows.length ? mapData(rows) : []\n  })\n\n  return {\n    data: {\n      results,\n    },\n    error: undefined,\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/data-sources/StaticDataSource.ts",
      "content": "import { ISequelizable, ISerializable } from '@jakub.knejzlik/ts-query'\nimport { StaticDatabase } from './database-metadata'\nimport { DataSource } from './DataSource'\nimport {\n  createDatabaseDatabaseOpts,\n  createStaticDatabase,\n  executeQueries,\n  StaticDataTables,\n} from './static-database'\n\nexport class StaticDataSource implements DataSource {\n  private db: Promise<StaticDatabase>\n  private contentHash: string\n\n  constructor(tables: StaticDataTables, opts?: createDatabaseDatabaseOpts) {\n    this.db = createStaticDatabase(tables, opts)\n    this.contentHash = new Date().toISOString()\n  }\n  getContentHash(): string {\n    return this.contentHash\n  }\n  async executeQueries(queries: Array<ISequelizable & ISerializable>): Promise<any> {\n    const db = await this.db\n    const { data } = executeQueries(db.database, queries)\n    return data.results\n  }\n  async execute(query: ISequelizable & ISerializable): Promise<any> {\n    const data = await this.executeQueries([query])\n    return data[0]\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/components/feedback/Spin.tsx",
      "content": "import * as React from 'react'\nimport { cn } from '@/lib/utils'\n\nexport interface SpinProps extends React.HTMLAttributes<HTMLDivElement> {\n  children: React.ReactNode\n  spinning?: boolean\n  overlayClassName?: string\n  spinnerClassName?: string\n  spinnerSize?: number\n  noBlur?: boolean\n  ref?: React.Ref<HTMLDivElement>\n}\n\nexport function Spin({\n  children,\n  spinning = false,\n  className,\n  overlayClassName,\n  spinnerClassName,\n  spinnerSize = 24,\n  noBlur = false,\n  ref,\n  ...props\n}: SpinProps) {\n  return (\n    <div ref={ref} className={cn('relative', className)} {...props}>\n      {children}\n      {spinning && (\n        <div\n          className={cn(\n            'absolute inset-0 flex items-center justify-center bg-background/50',\n            !noBlur && 'backdrop-blur-sm',\n            overlayClassName\n          )}\n        >\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width={spinnerSize}\n            height={spinnerSize}\n            viewBox=\"0 0 24 24\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            className={cn('animate-spin text-primary', spinnerClassName)}\n          >\n            <path d=\"M21 12a9 9 0 1 1-6.219-8.56\" />\n          </svg>\n        </div>\n      )}\n    </div>\n  )\n}\n\nSpin.displayName = 'Spin'",
      "type": "registry:component"
    }
  ]
}